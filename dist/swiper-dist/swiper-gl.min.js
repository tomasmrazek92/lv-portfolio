"use strict";
(() => {
  // bin/live-reload.js
  new EventSource(`${"http://localhost:3000"}/esbuild`).addEventListener("change", () => location.reload());

  // src/swiper-dist/swiper-gl.min.js
  !function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).SwiperGL = e();
  }(void 0, function() {
    "use strict";
    function t(t2) {
      let e2 = t2[0], i2 = t2[1], s2 = t2[2];
      return Math.sqrt(e2 * e2 + i2 * i2 + s2 * s2);
    }
    function e(t2, e2) {
      return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2;
    }
    function i(t2, e2, i2) {
      return t2[0] = e2[0] + i2[0], t2[1] = e2[1] + i2[1], t2[2] = e2[2] + i2[2], t2;
    }
    function s(t2, e2, i2) {
      return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
    }
    function r(t2, e2, i2) {
      return t2[0] = e2[0] * i2, t2[1] = e2[1] * i2, t2[2] = e2[2] * i2, t2;
    }
    function n(t2) {
      let e2 = t2[0], i2 = t2[1], s2 = t2[2];
      return e2 * e2 + i2 * i2 + s2 * s2;
    }
    function a(t2, e2) {
      let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = i2 * i2 + s2 * s2 + r2 * r2;
      return n2 > 0 && (n2 = 1 / Math.sqrt(n2)), t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2;
    }
    function o(t2, e2) {
      return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
    }
    function h(t2, e2, i2) {
      let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = i2[0], o2 = i2[1], h2 = i2[2];
      return t2[0] = r2 * h2 - n2 * o2, t2[1] = n2 * a2 - s2 * h2, t2[2] = s2 * o2 - r2 * a2, t2;
    }
    const l = function() {
      const t2 = [0, 0, 0], i2 = [0, 0, 0];
      return function(s2, r2) {
        e(t2, s2), e(i2, r2), a(t2, t2), a(i2, i2);
        let n2 = o(t2, i2);
        return n2 > 1 ? 0 : n2 < -1 ? Math.PI : Math.acos(n2);
      };
    }();
    class c extends Array {
      constructor(t2 = 0, e2 = t2, i2 = t2) {
        return super(t2, e2, i2), this;
      }
      get x() {
        return this[0];
      }
      get y() {
        return this[1];
      }
      get z() {
        return this[2];
      }
      set x(t2) {
        this[0] = t2;
      }
      set y(t2) {
        this[1] = t2;
      }
      set z(t2) {
        this[2] = t2;
      }
      set(t2, e2 = t2, i2 = t2) {
        return t2.length ? this.copy(t2) : (function(t3, e3, i3, s2) {
          t3[0] = e3, t3[1] = i3, t3[2] = s2;
        }(this, t2, e2, i2), this);
      }
      copy(t2) {
        return e(this, t2), this;
      }
      add(t2, e2) {
        return e2 ? i(this, t2, e2) : i(this, this, t2), this;
      }
      sub(t2, e2) {
        return e2 ? s(this, t2, e2) : s(this, this, t2), this;
      }
      multiply(t2) {
        var e2, i2, s2;
        return t2.length ? (i2 = this, s2 = t2, (e2 = this)[0] = i2[0] * s2[0], e2[1] = i2[1] * s2[1], e2[2] = i2[2] * s2[2]) : r(this, this, t2), this;
      }
      divide(t2) {
        var e2, i2, s2;
        return t2.length ? (i2 = this, s2 = t2, (e2 = this)[0] = i2[0] / s2[0], e2[1] = i2[1] / s2[1], e2[2] = i2[2] / s2[2]) : r(this, this, 1 / t2), this;
      }
      inverse(t2 = this) {
        var e2, i2;
        return i2 = t2, (e2 = this)[0] = 1 / i2[0], e2[1] = 1 / i2[1], e2[2] = 1 / i2[2], this;
      }
      len() {
        return t(this);
      }
      distance(e2) {
        return e2 ? function(t2, e3) {
          let i2 = e3[0] - t2[0], s2 = e3[1] - t2[1], r2 = e3[2] - t2[2];
          return Math.sqrt(i2 * i2 + s2 * s2 + r2 * r2);
        }(this, e2) : t(this);
      }
      squaredLen() {
        return n(this);
      }
      squaredDistance(t2) {
        return t2 ? function(t3, e2) {
          let i2 = e2[0] - t3[0], s2 = e2[1] - t3[1], r2 = e2[2] - t3[2];
          return i2 * i2 + s2 * s2 + r2 * r2;
        }(this, t2) : n(this);
      }
      negate(t2 = this) {
        var e2, i2;
        return i2 = t2, (e2 = this)[0] = -i2[0], e2[1] = -i2[1], e2[2] = -i2[2], this;
      }
      cross(t2, e2) {
        return e2 ? h(this, t2, e2) : h(this, this, t2), this;
      }
      scale(t2) {
        return r(this, this, t2), this;
      }
      normalize() {
        return a(this, this), this;
      }
      dot(t2) {
        return o(this, t2);
      }
      equals(t2) {
        return i2 = t2, (e2 = this)[0] === i2[0] && e2[1] === i2[1] && e2[2] === i2[2];
        var e2, i2;
      }
      applyMatrix3(t2) {
        return function(t3, e2, i2) {
          let s2 = e2[0], r2 = e2[1], n2 = e2[2];
          t3[0] = s2 * i2[0] + r2 * i2[3] + n2 * i2[6], t3[1] = s2 * i2[1] + r2 * i2[4] + n2 * i2[7], t3[2] = s2 * i2[2] + r2 * i2[5] + n2 * i2[8];
        }(this, this, t2), this;
      }
      applyMatrix4(t2) {
        return function(t3, e2, i2) {
          let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = i2[3] * s2 + i2[7] * r2 + i2[11] * n2 + i2[15];
          a2 = a2 || 1, t3[0] = (i2[0] * s2 + i2[4] * r2 + i2[8] * n2 + i2[12]) / a2, t3[1] = (i2[1] * s2 + i2[5] * r2 + i2[9] * n2 + i2[13]) / a2, t3[2] = (i2[2] * s2 + i2[6] * r2 + i2[10] * n2 + i2[14]) / a2;
        }(this, this, t2), this;
      }
      scaleRotateMatrix4(t2) {
        return function(t3, e2, i2) {
          let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = i2[3] * s2 + i2[7] * r2 + i2[11] * n2 + i2[15];
          a2 = a2 || 1, t3[0] = (i2[0] * s2 + i2[4] * r2 + i2[8] * n2) / a2, t3[1] = (i2[1] * s2 + i2[5] * r2 + i2[9] * n2) / a2, t3[2] = (i2[2] * s2 + i2[6] * r2 + i2[10] * n2) / a2;
        }(this, this, t2), this;
      }
      applyQuaternion(t2) {
        return function(t3, e2, i2) {
          let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = i2[0], o2 = i2[1], h2 = i2[2], l2 = o2 * n2 - h2 * r2, c2 = h2 * s2 - a2 * n2, u2 = a2 * r2 - o2 * s2, g2 = o2 * u2 - h2 * c2, d2 = h2 * l2 - a2 * u2, m2 = a2 * c2 - o2 * l2, p2 = 2 * i2[3];
          l2 *= p2, c2 *= p2, u2 *= p2, g2 *= 2, d2 *= 2, m2 *= 2, t3[0] = s2 + l2 + g2, t3[1] = r2 + c2 + d2, t3[2] = n2 + u2 + m2;
        }(this, this, t2), this;
      }
      angle(t2) {
        return l(this, t2);
      }
      lerp(t2, e2) {
        return function(t3, e3, i2, s2) {
          let r2 = e3[0], n2 = e3[1], a2 = e3[2];
          t3[0] = r2 + s2 * (i2[0] - r2), t3[1] = n2 + s2 * (i2[1] - n2), t3[2] = a2 + s2 * (i2[2] - a2);
        }(this, this, t2, e2), this;
      }
      clone() {
        return new c(this[0], this[1], this[2]);
      }
      fromArray(t2, e2 = 0) {
        return this[0] = t2[e2], this[1] = t2[e2 + 1], this[2] = t2[e2 + 2], this;
      }
      toArray(t2 = [], e2 = 0) {
        return t2[e2] = this[0], t2[e2 + 1] = this[1], t2[e2 + 2] = this[2], t2;
      }
      transformDirection(t2) {
        const e2 = this[0], i2 = this[1], s2 = this[2];
        return this[0] = t2[0] * e2 + t2[4] * i2 + t2[8] * s2, this[1] = t2[1] * e2 + t2[5] * i2 + t2[9] * s2, this[2] = t2[2] * e2 + t2[6] * i2 + t2[10] * s2, this.normalize();
      }
    }
    const u = new c();
    let g = 1, d = 1, m = false;
    class p {
      constructor(t2, e2 = {}) {
        t2.canvas || console.error("gl not passed as first argument to Geometry"), this.gl = t2, this.attributes = e2, this.id = g++, this.VAOs = {}, this.drawRange = { start: 0, count: 0 }, this.instancedCount = 0, this.gl.renderer.bindVertexArray(null), this.gl.renderer.currentGeometry = null, this.glState = this.gl.renderer.state;
        for (let t3 in e2)
          this.addAttribute(t3, e2[t3]);
      }
      addAttribute(t2, e2) {
        if (this.attributes[t2] = e2, e2.id = d++, e2.size = e2.size || 1, e2.type = e2.type || (e2.data.constructor === Float32Array ? this.gl.FLOAT : e2.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT), e2.target = "index" === t2 ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER, e2.normalized = e2.normalized || false, e2.stride = e2.stride || 0, e2.offset = e2.offset || 0, e2.count = e2.count || (e2.stride ? e2.data.byteLength / e2.stride : e2.data.length / e2.size), e2.divisor = e2.instanced || 0, e2.needsUpdate = false, e2.usage = e2.usage || this.gl.STATIC_DRAW, e2.buffer || this.updateAttribute(e2), e2.divisor) {
          if (this.isInstanced = true, this.instancedCount && this.instancedCount !== e2.count * e2.divisor)
            return console.warn("geometry has multiple instanced buffers of different length"), this.instancedCount = Math.min(this.instancedCount, e2.count * e2.divisor);
          this.instancedCount = e2.count * e2.divisor;
        } else
          "index" === t2 ? this.drawRange.count = e2.count : this.attributes.index || (this.drawRange.count = Math.max(this.drawRange.count, e2.count));
      }
      updateAttribute(t2) {
        const e2 = !t2.buffer;
        e2 && (t2.buffer = this.gl.createBuffer()), this.glState.boundBuffer !== t2.buffer && (this.gl.bindBuffer(t2.target, t2.buffer), this.glState.boundBuffer = t2.buffer), e2 ? this.gl.bufferData(t2.target, t2.data, t2.usage) : this.gl.bufferSubData(t2.target, 0, t2.data), t2.needsUpdate = false;
      }
      setIndex(t2) {
        this.addAttribute("index", t2);
      }
      setDrawRange(t2, e2) {
        this.drawRange.start = t2, this.drawRange.count = e2;
      }
      setInstancedCount(t2) {
        this.instancedCount = t2;
      }
      createVAO(t2) {
        this.VAOs[t2.attributeOrder] = this.gl.renderer.createVertexArray(), this.gl.renderer.bindVertexArray(this.VAOs[t2.attributeOrder]), this.bindAttributes(t2);
      }
      bindAttributes(t2) {
        t2.attributeLocations.forEach((t3, { name: e2, type: i2 }) => {
          if (!this.attributes[e2])
            return void console.warn(`active attribute ${e2} not being supplied`);
          const s2 = this.attributes[e2];
          this.gl.bindBuffer(s2.target, s2.buffer), this.glState.boundBuffer = s2.buffer;
          let r2 = 1;
          35674 === i2 && (r2 = 2), 35675 === i2 && (r2 = 3), 35676 === i2 && (r2 = 4);
          const n2 = s2.size / r2, a2 = 1 === r2 ? 0 : r2 * r2 * r2, o2 = 1 === r2 ? 0 : r2 * r2;
          for (let e3 = 0; e3 < r2; e3++)
            this.gl.vertexAttribPointer(t3 + e3, n2, s2.type, s2.normalized, s2.stride + a2, s2.offset + e3 * o2), this.gl.enableVertexAttribArray(t3 + e3), this.gl.renderer.vertexAttribDivisor(t3 + e3, s2.divisor);
        }), this.attributes.index && this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);
      }
      draw({ program: t2, mode: e2 = this.gl.TRIANGLES }) {
        this.gl.renderer.currentGeometry !== `${this.id}_${t2.attributeOrder}` && (this.VAOs[t2.attributeOrder] || this.createVAO(t2), this.gl.renderer.bindVertexArray(this.VAOs[t2.attributeOrder]), this.gl.renderer.currentGeometry = `${this.id}_${t2.attributeOrder}`), t2.attributeLocations.forEach((t3, { name: e3 }) => {
          const i2 = this.attributes[e3];
          i2.needsUpdate && this.updateAttribute(i2);
        }), this.isInstanced ? this.attributes.index ? this.gl.renderer.drawElementsInstanced(e2, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + 2 * this.drawRange.start, this.instancedCount) : this.gl.renderer.drawArraysInstanced(e2, this.drawRange.start, this.drawRange.count, this.instancedCount) : this.attributes.index ? this.gl.drawElements(e2, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + 2 * this.drawRange.start) : this.gl.drawArrays(e2, this.drawRange.start, this.drawRange.count);
      }
      getPosition() {
        const t2 = this.attributes.position;
        return t2.data ? t2 : m ? void 0 : (console.warn("No position buffer data found to compute bounds"), m = true);
      }
      computeBoundingBox(t2) {
        t2 || (t2 = this.getPosition());
        const e2 = t2.data, i2 = t2.stride ? t2.stride / e2.BYTES_PER_ELEMENT : t2.size;
        this.bounds || (this.bounds = { min: new c(), max: new c(), center: new c(), scale: new c(), radius: 1 / 0 });
        const s2 = this.bounds.min, r2 = this.bounds.max, n2 = this.bounds.center, a2 = this.bounds.scale;
        s2.set(1 / 0), r2.set(-1 / 0);
        for (let t3 = 0, n3 = e2.length; t3 < n3; t3 += i2) {
          const i3 = e2[t3], n4 = e2[t3 + 1], a3 = e2[t3 + 2];
          s2.x = Math.min(i3, s2.x), s2.y = Math.min(n4, s2.y), s2.z = Math.min(a3, s2.z), r2.x = Math.max(i3, r2.x), r2.y = Math.max(n4, r2.y), r2.z = Math.max(a3, r2.z);
        }
        a2.sub(r2, s2), n2.add(s2, r2).divide(2);
      }
      computeBoundingSphere(t2) {
        t2 || (t2 = this.getPosition());
        const e2 = t2.data, i2 = t2.stride ? t2.stride / e2.BYTES_PER_ELEMENT : t2.size;
        this.bounds || this.computeBoundingBox(t2);
        let s2 = 0;
        for (let t3 = 0, r2 = e2.length; t3 < r2; t3 += i2)
          u.fromArray(e2, t3), s2 = Math.max(s2, this.bounds.center.squaredDistance(u));
        this.bounds.radius = Math.sqrt(s2);
      }
      remove() {
        for (let t2 in this.VAOs)
          this.gl.renderer.deleteVertexArray(this.VAOs[t2]), delete this.VAOs[t2];
        for (let t2 in this.attributes)
          this.gl.deleteBuffer(this.attributes[t2].buffer), delete this.attributes[t2];
      }
    }
    let x = 1;
    const f = {};
    class v {
      constructor(t2, { vertex: e2, fragment: i2, uniforms: s2 = {}, transparent: r2 = false, cullFace: n2 = t2.BACK, frontFace: a2 = t2.CCW, depthTest: o2 = true, depthWrite: h2 = true, depthFunc: l2 = t2.LESS } = {}) {
        t2.canvas || console.error("gl not passed as fist argument to Program"), this.gl = t2, this.uniforms = s2, this.id = x++, e2 || console.warn("vertex shader not supplied"), i2 || console.warn("fragment shader not supplied"), this.transparent = r2, this.cullFace = n2, this.frontFace = a2, this.depthTest = o2, this.depthWrite = h2, this.depthFunc = l2, this.blendFunc = {}, this.blendEquation = {}, this.transparent && !this.blendFunc.src && (this.gl.renderer.premultipliedAlpha ? this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA) : this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA));
        const c2 = t2.createShader(t2.VERTEX_SHADER);
        t2.shaderSource(c2, e2), t2.compileShader(c2), "" !== t2.getShaderInfoLog(c2) && console.warn(`${t2.getShaderInfoLog(c2)}
Vertex Shader
${M(e2)}`);
        const u2 = t2.createShader(t2.FRAGMENT_SHADER);
        if (t2.shaderSource(u2, i2), t2.compileShader(u2), "" !== t2.getShaderInfoLog(u2) && console.warn(`${t2.getShaderInfoLog(u2)}
Fragment Shader
${M(i2)}`), this.program = t2.createProgram(), t2.attachShader(this.program, c2), t2.attachShader(this.program, u2), t2.linkProgram(this.program), !t2.getProgramParameter(this.program, t2.LINK_STATUS))
          return console.warn(t2.getProgramInfoLog(this.program));
        t2.deleteShader(c2), t2.deleteShader(u2), this.uniformLocations = /* @__PURE__ */ new Map();
        let g2 = t2.getProgramParameter(this.program, t2.ACTIVE_UNIFORMS);
        for (let e3 = 0; e3 < g2; e3++) {
          let i3 = t2.getActiveUniform(this.program, e3);
          this.uniformLocations.set(i3, t2.getUniformLocation(this.program, i3.name));
          const s3 = i3.name.match(/(\w+)/g);
          i3.uniformName = s3[0], 3 === s3.length ? (i3.isStructArray = true, i3.structIndex = Number(s3[1]), i3.structProperty = s3[2]) : 2 === s3.length && isNaN(Number(s3[1])) && (i3.isStruct = true, i3.structProperty = s3[1]);
        }
        this.attributeLocations = /* @__PURE__ */ new Map();
        const d2 = [], m2 = t2.getProgramParameter(this.program, t2.ACTIVE_ATTRIBUTES);
        for (let e3 = 0; e3 < m2; e3++) {
          const i3 = t2.getActiveAttrib(this.program, e3), s3 = t2.getAttribLocation(this.program, i3.name);
          -1 !== s3 && (d2[s3] = i3.name, this.attributeLocations.set(i3, s3));
        }
        this.attributeOrder = d2.join("");
      }
      setBlendFunc(t2, e2, i2, s2) {
        this.blendFunc.src = t2, this.blendFunc.dst = e2, this.blendFunc.srcAlpha = i2, this.blendFunc.dstAlpha = s2, t2 && (this.transparent = true);
      }
      setBlendEquation(t2, e2) {
        this.blendEquation.modeRGB = t2, this.blendEquation.modeAlpha = e2;
      }
      applyState() {
        this.depthTest ? this.gl.renderer.enable(this.gl.DEPTH_TEST) : this.gl.renderer.disable(this.gl.DEPTH_TEST), this.cullFace ? this.gl.renderer.enable(this.gl.CULL_FACE) : this.gl.renderer.disable(this.gl.CULL_FACE), this.blendFunc.src ? this.gl.renderer.enable(this.gl.BLEND) : this.gl.renderer.disable(this.gl.BLEND), this.cullFace && this.gl.renderer.setCullFace(this.cullFace), this.gl.renderer.setFrontFace(this.frontFace), this.gl.renderer.setDepthMask(this.depthWrite), this.gl.renderer.setDepthFunc(this.depthFunc), this.blendFunc.src && this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha), this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);
      }
      use({ flipFaces: t2 = false } = {}) {
        let e2 = -1;
        this.gl.renderer.state.currentProgram === this.id || (this.gl.useProgram(this.program), this.gl.renderer.state.currentProgram = this.id), this.uniformLocations.forEach((t3, i2) => {
          let s2 = i2.uniformName, r2 = this.uniforms[s2];
          if (i2.isStruct && (r2 = r2[i2.structProperty], s2 += `.${i2.structProperty}`), i2.isStructArray && (r2 = r2[i2.structIndex][i2.structProperty], s2 += `[${i2.structIndex}].${i2.structProperty}`), !r2)
            return y(`Active uniform ${s2} has not been supplied`);
          if (r2 && void 0 === r2.value)
            return y(`${s2} uniform is missing a value parameter`);
          if (r2.value.texture)
            return e2 += 1, r2.value.update(e2), A(this.gl, i2.type, t3, e2);
          if (r2.value.length && r2.value[0].texture) {
            const s3 = [];
            return r2.value.forEach((t4) => {
              e2 += 1, t4.update(e2), s3.push(e2);
            }), A(this.gl, i2.type, t3, s3);
          }
          A(this.gl, i2.type, t3, r2.value);
        }), this.applyState(), t2 && this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);
      }
      remove() {
        this.gl.deleteProgram(this.program);
      }
    }
    function A(t2, e2, i2, s2) {
      s2 = s2.length ? function(t3) {
        const e3 = t3.length, i3 = t3[0].length;
        if (void 0 === i3)
          return t3;
        const s3 = e3 * i3;
        let r3 = f[s3];
        r3 || (f[s3] = r3 = new Float32Array(s3));
        for (let s4 = 0; s4 < e3; s4++)
          r3.set(t3[s4], s4 * i3);
        return r3;
      }(s2) : s2;
      const r2 = t2.renderer.state.uniformLocations.get(i2);
      if (s2.length)
        if (void 0 === r2 || r2.length !== s2.length)
          t2.renderer.state.uniformLocations.set(i2, s2.slice(0));
        else {
          if (function(t3, e3) {
            if (t3.length !== e3.length)
              return false;
            for (let i3 = 0, s3 = t3.length; i3 < s3; i3++)
              if (t3[i3] !== e3[i3])
                return false;
            return true;
          }(r2, s2))
            return;
          r2.set ? r2.set(s2) : function(t3, e3) {
            for (let i3 = 0, s3 = t3.length; i3 < s3; i3++)
              t3[i3] = e3[i3];
          }(r2, s2), t2.renderer.state.uniformLocations.set(i2, r2);
        }
      else {
        if (r2 === s2)
          return;
        t2.renderer.state.uniformLocations.set(i2, s2);
      }
      switch (e2) {
        case 5126:
          return s2.length ? t2.uniform1fv(i2, s2) : t2.uniform1f(i2, s2);
        case 35664:
          return t2.uniform2fv(i2, s2);
        case 35665:
          return t2.uniform3fv(i2, s2);
        case 35666:
          return t2.uniform4fv(i2, s2);
        case 35670:
        case 5124:
        case 35678:
        case 35680:
          return s2.length ? t2.uniform1iv(i2, s2) : t2.uniform1i(i2, s2);
        case 35671:
        case 35667:
          return t2.uniform2iv(i2, s2);
        case 35672:
        case 35668:
          return t2.uniform3iv(i2, s2);
        case 35673:
        case 35669:
          return t2.uniform4iv(i2, s2);
        case 35674:
          return t2.uniformMatrix2fv(i2, false, s2);
        case 35675:
          return t2.uniformMatrix3fv(i2, false, s2);
        case 35676:
          return t2.uniformMatrix4fv(i2, false, s2);
      }
    }
    function M(t2) {
      let e2 = t2.split("\n");
      for (let t3 = 0; t3 < e2.length; t3++)
        e2[t3] = t3 + 1 + ": " + e2[t3];
      return e2.join("\n");
    }
    let w = 0;
    function y(t2) {
      w > 100 || (console.warn(t2), w++, w > 100 && console.warn("More than 100 program warnings - stopping logs."));
    }
    const E = new c();
    let U = 1;
    class F {
      constructor({ canvas: t2 = document.createElement("canvas"), width: e2 = 300, height: i2 = 150, dpr: s2 = 1, alpha: r2 = false, depth: n2 = true, stencil: a2 = false, antialias: o2 = false, premultipliedAlpha: h2 = false, preserveDrawingBuffer: l2 = false, powerPreference: c2 = "default", autoClear: u2 = true, webgl: g2 = 2 } = {}) {
        const d2 = { alpha: r2, depth: n2, stencil: a2, antialias: o2, premultipliedAlpha: h2, preserveDrawingBuffer: l2, powerPreference: c2 };
        this.dpr = s2, this.alpha = r2, this.color = true, this.depth = n2, this.stencil = a2, this.premultipliedAlpha = h2, this.autoClear = u2, this.id = U++, 2 === g2 && (this.gl = t2.getContext("webgl2", d2)), this.isWebgl2 = !!this.gl, this.gl || (this.gl = t2.getContext("webgl", d2)), this.gl || console.error("unable to create webgl context"), this.gl.renderer = this, this.setSize(e2, i2), this.state = {}, this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO }, this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD }, this.state.cullFace = null, this.state.frontFace = this.gl.CCW, this.state.depthMask = true, this.state.depthFunc = this.gl.LESS, this.state.premultiplyAlpha = false, this.state.flipY = false, this.state.unpackAlignment = 4, this.state.framebuffer = null, this.state.viewport = { x: 0, y: 0, width: null, height: null }, this.state.textureUnits = [], this.state.activeTextureUnit = 0, this.state.boundBuffer = null, this.state.uniformLocations = /* @__PURE__ */ new Map(), this.state.currentProgram = null, this.extensions = {}, this.isWebgl2 ? (this.getExtension("EXT_color_buffer_float"), this.getExtension("OES_texture_float_linear")) : (this.getExtension("OES_texture_float"), this.getExtension("OES_texture_float_linear"), this.getExtension("OES_texture_half_float"), this.getExtension("OES_texture_half_float_linear"), this.getExtension("OES_element_index_uint"), this.getExtension("OES_standard_derivatives"), this.getExtension("EXT_sRGB"), this.getExtension("WEBGL_depth_texture"), this.getExtension("WEBGL_draw_buffers")), this.getExtension("WEBGL_compressed_texture_astc"), this.getExtension("EXT_texture_compression_bptc"), this.getExtension("WEBGL_compressed_texture_s3tc"), this.getExtension("WEBGL_compressed_texture_etc1"), this.getExtension("WEBGL_compressed_texture_pvrtc"), this.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), this.vertexAttribDivisor = this.getExtension("ANGLE_instanced_arrays", "vertexAttribDivisor", "vertexAttribDivisorANGLE"), this.drawArraysInstanced = this.getExtension("ANGLE_instanced_arrays", "drawArraysInstanced", "drawArraysInstancedANGLE"), this.drawElementsInstanced = this.getExtension("ANGLE_instanced_arrays", "drawElementsInstanced", "drawElementsInstancedANGLE"), this.createVertexArray = this.getExtension("OES_vertex_array_object", "createVertexArray", "createVertexArrayOES"), this.bindVertexArray = this.getExtension("OES_vertex_array_object", "bindVertexArray", "bindVertexArrayOES"), this.deleteVertexArray = this.getExtension("OES_vertex_array_object", "deleteVertexArray", "deleteVertexArrayOES"), this.drawBuffers = this.getExtension("WEBGL_draw_buffers", "drawBuffers", "drawBuffersWEBGL"), this.parameters = {}, this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS), this.parameters.maxAnisotropy = this.getExtension("EXT_texture_filter_anisotropic") ? this.gl.getParameter(this.getExtension("EXT_texture_filter_anisotropic").MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      }
      setSize(t2, e2) {
        this.width = t2, this.height = e2, this.gl.canvas.width = t2 * this.dpr, this.gl.canvas.height = e2 * this.dpr, Object.assign(this.gl.canvas.style, { width: t2 + "px", height: e2 + "px" });
      }
      setViewport(t2, e2, i2 = 0, s2 = 0) {
        this.state.viewport.width === t2 && this.state.viewport.height === e2 || (this.state.viewport.width = t2, this.state.viewport.height = e2, this.state.viewport.x = i2, this.state.viewport.y = s2, this.gl.viewport(i2, s2, t2, e2));
      }
      setScissor(t2, e2, i2 = 0, s2 = 0) {
        this.gl.scissor(i2, s2, t2, e2);
      }
      enable(t2) {
        true !== this.state[t2] && (this.gl.enable(t2), this.state[t2] = true);
      }
      disable(t2) {
        false !== this.state[t2] && (this.gl.disable(t2), this.state[t2] = false);
      }
      setBlendFunc(t2, e2, i2, s2) {
        this.state.blendFunc.src === t2 && this.state.blendFunc.dst === e2 && this.state.blendFunc.srcAlpha === i2 && this.state.blendFunc.dstAlpha === s2 || (this.state.blendFunc.src = t2, this.state.blendFunc.dst = e2, this.state.blendFunc.srcAlpha = i2, this.state.blendFunc.dstAlpha = s2, void 0 !== i2 ? this.gl.blendFuncSeparate(t2, e2, i2, s2) : this.gl.blendFunc(t2, e2));
      }
      setBlendEquation(t2, e2) {
        t2 = t2 || this.gl.FUNC_ADD, this.state.blendEquation.modeRGB === t2 && this.state.blendEquation.modeAlpha === e2 || (this.state.blendEquation.modeRGB = t2, this.state.blendEquation.modeAlpha = e2, void 0 !== e2 ? this.gl.blendEquationSeparate(t2, e2) : this.gl.blendEquation(t2));
      }
      setCullFace(t2) {
        this.state.cullFace !== t2 && (this.state.cullFace = t2, this.gl.cullFace(t2));
      }
      setFrontFace(t2) {
        this.state.frontFace !== t2 && (this.state.frontFace = t2, this.gl.frontFace(t2));
      }
      setDepthMask(t2) {
        this.state.depthMask !== t2 && (this.state.depthMask = t2, this.gl.depthMask(t2));
      }
      setDepthFunc(t2) {
        this.state.depthFunc !== t2 && (this.state.depthFunc = t2, this.gl.depthFunc(t2));
      }
      activeTexture(t2) {
        this.state.activeTextureUnit !== t2 && (this.state.activeTextureUnit = t2, this.gl.activeTexture(this.gl.TEXTURE0 + t2));
      }
      bindFramebuffer({ target: t2 = this.gl.FRAMEBUFFER, buffer: e2 = null } = {}) {
        this.state.framebuffer !== e2 && (this.state.framebuffer = e2, this.gl.bindFramebuffer(t2, e2));
      }
      getExtension(t2, e2, i2) {
        return e2 && this.gl[e2] ? this.gl[e2].bind(this.gl) : (this.extensions[t2] || (this.extensions[t2] = this.gl.getExtension(t2)), e2 ? this.extensions[t2] ? this.extensions[t2][i2].bind(this.extensions[t2]) : null : this.extensions[t2]);
      }
      sortOpaque(t2, e2) {
        return t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.program.id !== e2.program.id ? t2.program.id - e2.program.id : t2.zDepth !== e2.zDepth ? t2.zDepth - e2.zDepth : e2.id - t2.id;
      }
      sortTransparent(t2, e2) {
        return t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.zDepth !== e2.zDepth ? e2.zDepth - t2.zDepth : e2.id - t2.id;
      }
      sortUI(t2, e2) {
        return t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.program.id !== e2.program.id ? t2.program.id - e2.program.id : e2.id - t2.id;
      }
      getRenderList({ scene: t2, camera: e2, frustumCull: i2, sort: s2 }) {
        let r2 = [];
        if (e2 && i2 && e2.updateFrustum(), t2.traverse((t3) => {
          if (!t3.visible)
            return true;
          t3.draw && (i2 && t3.frustumCulled && e2 && !e2.frustumIntersectsMesh(t3) || r2.push(t3));
        }), s2) {
          const t3 = [], i3 = [], s3 = [];
          r2.forEach((r3) => {
            r3.program.transparent ? r3.program.depthTest ? i3.push(r3) : s3.push(r3) : t3.push(r3), r3.zDepth = 0, 0 === r3.renderOrder && r3.program.depthTest && e2 && (r3.worldMatrix.getTranslation(E), E.applyMatrix4(e2.projectionViewMatrix), r3.zDepth = E.z);
          }), t3.sort(this.sortOpaque), i3.sort(this.sortTransparent), s3.sort(this.sortUI), r2 = t3.concat(i3, s3);
        }
        return r2;
      }
      render({ scene: t2, camera: e2, target: i2 = null, update: s2 = true, sort: r2 = true, frustumCull: n2 = true, clear: a2 }) {
        null === i2 ? (this.bindFramebuffer(), this.setViewport(this.width * this.dpr, this.height * this.dpr)) : (this.bindFramebuffer(i2), this.setViewport(i2.width, i2.height)), (a2 || this.autoClear && false !== a2) && (!this.depth || i2 && !i2.depth || (this.enable(this.gl.DEPTH_TEST), this.setDepthMask(true)), this.gl.clear((this.color ? this.gl.COLOR_BUFFER_BIT : 0) | (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0))), s2 && t2.updateMatrixWorld(), e2 && e2.updateMatrixWorld();
        this.getRenderList({ scene: t2, camera: e2, frustumCull: n2, sort: r2 }).forEach((t3) => {
          t3.draw({ camera: e2 });
        });
      }
    }
    function C(t2, e2) {
      return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2;
    }
    function R(t2, e2, i2, s2, r2) {
      return t2[0] = e2, t2[1] = i2, t2[2] = s2, t2[3] = r2, t2;
    }
    function b(t2, e2) {
      let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = i2 * i2 + s2 * s2 + r2 * r2 + n2 * n2;
      return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = i2 * a2, t2[1] = s2 * a2, t2[2] = r2 * a2, t2[3] = n2 * a2, t2;
    }
    function T(t2, e2) {
      return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
    }
    function I(t2, e2, i2) {
      let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = e2[3], o2 = i2[0], h2 = i2[1], l2 = i2[2], c2 = i2[3];
      return t2[0] = s2 * c2 + a2 * o2 + r2 * l2 - n2 * h2, t2[1] = r2 * c2 + a2 * h2 + n2 * o2 - s2 * l2, t2[2] = n2 * c2 + a2 * l2 + s2 * h2 - r2 * o2, t2[3] = a2 * c2 - s2 * o2 - r2 * h2 - n2 * l2, t2;
    }
    const G = C, S = R, Y = T, B = b;
    class D extends Array {
      constructor(t2 = 0, e2 = 0, i2 = 0, s2 = 1) {
        return super(t2, e2, i2, s2), this.onChange = () => {
        }, this;
      }
      get x() {
        return this[0];
      }
      get y() {
        return this[1];
      }
      get z() {
        return this[2];
      }
      get w() {
        return this[3];
      }
      set x(t2) {
        this[0] = t2, this.onChange();
      }
      set y(t2) {
        this[1] = t2, this.onChange();
      }
      set z(t2) {
        this[2] = t2, this.onChange();
      }
      set w(t2) {
        this[3] = t2, this.onChange();
      }
      identity() {
        var t2;
        return (t2 = this)[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, this.onChange(), this;
      }
      set(t2, e2, i2, s2) {
        return t2.length ? this.copy(t2) : (S(this, t2, e2, i2, s2), this.onChange(), this);
      }
      rotateX(t2) {
        return function(t3, e2, i2) {
          i2 *= 0.5;
          let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = e2[3], o2 = Math.sin(i2), h2 = Math.cos(i2);
          t3[0] = s2 * h2 + a2 * o2, t3[1] = r2 * h2 + n2 * o2, t3[2] = n2 * h2 - r2 * o2, t3[3] = a2 * h2 - s2 * o2;
        }(this, this, t2), this.onChange(), this;
      }
      rotateY(t2) {
        return function(t3, e2, i2) {
          i2 *= 0.5;
          let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = e2[3], o2 = Math.sin(i2), h2 = Math.cos(i2);
          t3[0] = s2 * h2 - n2 * o2, t3[1] = r2 * h2 + a2 * o2, t3[2] = n2 * h2 + s2 * o2, t3[3] = a2 * h2 - r2 * o2;
        }(this, this, t2), this.onChange(), this;
      }
      rotateZ(t2) {
        return function(t3, e2, i2) {
          i2 *= 0.5;
          let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = e2[3], o2 = Math.sin(i2), h2 = Math.cos(i2);
          t3[0] = s2 * h2 + r2 * o2, t3[1] = r2 * h2 - s2 * o2, t3[2] = n2 * h2 + a2 * o2, t3[3] = a2 * h2 - n2 * o2;
        }(this, this, t2), this.onChange(), this;
      }
      inverse(t2 = this) {
        return function(t3, e2) {
          let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = i2 * i2 + s2 * s2 + r2 * r2 + n2 * n2, o2 = a2 ? 1 / a2 : 0;
          t3[0] = -i2 * o2, t3[1] = -s2 * o2, t3[2] = -r2 * o2, t3[3] = n2 * o2;
        }(this, t2), this.onChange(), this;
      }
      conjugate(t2 = this) {
        var e2, i2;
        return i2 = t2, (e2 = this)[0] = -i2[0], e2[1] = -i2[1], e2[2] = -i2[2], e2[3] = i2[3], this.onChange(), this;
      }
      copy(t2) {
        return G(this, t2), this.onChange(), this;
      }
      normalize(t2 = this) {
        return B(this, t2), this.onChange(), this;
      }
      multiply(t2, e2) {
        return e2 ? I(this, t2, e2) : I(this, this, t2), this.onChange(), this;
      }
      dot(t2) {
        return Y(this, t2);
      }
      fromMatrix3(t2) {
        return function(t3, e2) {
          let i2, s2 = e2[0] + e2[4] + e2[8];
          if (s2 > 0)
            i2 = Math.sqrt(s2 + 1), t3[3] = 0.5 * i2, i2 = 0.5 / i2, t3[0] = (e2[5] - e2[7]) * i2, t3[1] = (e2[6] - e2[2]) * i2, t3[2] = (e2[1] - e2[3]) * i2;
          else {
            let s3 = 0;
            e2[4] > e2[0] && (s3 = 1), e2[8] > e2[3 * s3 + s3] && (s3 = 2);
            let r2 = (s3 + 1) % 3, n2 = (s3 + 2) % 3;
            i2 = Math.sqrt(e2[3 * s3 + s3] - e2[3 * r2 + r2] - e2[3 * n2 + n2] + 1), t3[s3] = 0.5 * i2, i2 = 0.5 / i2, t3[3] = (e2[3 * r2 + n2] - e2[3 * n2 + r2]) * i2, t3[r2] = (e2[3 * r2 + s3] + e2[3 * s3 + r2]) * i2, t3[n2] = (e2[3 * n2 + s3] + e2[3 * s3 + n2]) * i2;
          }
        }(this, t2), this.onChange(), this;
      }
      fromEuler(t2) {
        return function(t3, e2, i2 = "YXZ") {
          let s2 = Math.sin(0.5 * e2[0]), r2 = Math.cos(0.5 * e2[0]), n2 = Math.sin(0.5 * e2[1]), a2 = Math.cos(0.5 * e2[1]), o2 = Math.sin(0.5 * e2[2]), h2 = Math.cos(0.5 * e2[2]);
          "XYZ" === i2 ? (t3[0] = s2 * a2 * h2 + r2 * n2 * o2, t3[1] = r2 * n2 * h2 - s2 * a2 * o2, t3[2] = r2 * a2 * o2 + s2 * n2 * h2, t3[3] = r2 * a2 * h2 - s2 * n2 * o2) : "YXZ" === i2 ? (t3[0] = s2 * a2 * h2 + r2 * n2 * o2, t3[1] = r2 * n2 * h2 - s2 * a2 * o2, t3[2] = r2 * a2 * o2 - s2 * n2 * h2, t3[3] = r2 * a2 * h2 + s2 * n2 * o2) : "ZXY" === i2 ? (t3[0] = s2 * a2 * h2 - r2 * n2 * o2, t3[1] = r2 * n2 * h2 + s2 * a2 * o2, t3[2] = r2 * a2 * o2 + s2 * n2 * h2, t3[3] = r2 * a2 * h2 - s2 * n2 * o2) : "ZYX" === i2 ? (t3[0] = s2 * a2 * h2 - r2 * n2 * o2, t3[1] = r2 * n2 * h2 + s2 * a2 * o2, t3[2] = r2 * a2 * o2 - s2 * n2 * h2, t3[3] = r2 * a2 * h2 + s2 * n2 * o2) : "YZX" === i2 ? (t3[0] = s2 * a2 * h2 + r2 * n2 * o2, t3[1] = r2 * n2 * h2 + s2 * a2 * o2, t3[2] = r2 * a2 * o2 - s2 * n2 * h2, t3[3] = r2 * a2 * h2 - s2 * n2 * o2) : "XZY" === i2 && (t3[0] = s2 * a2 * h2 - r2 * n2 * o2, t3[1] = r2 * n2 * h2 - s2 * a2 * o2, t3[2] = r2 * a2 * o2 + s2 * n2 * h2, t3[3] = r2 * a2 * h2 + s2 * n2 * o2);
        }(this, t2, t2.order), this;
      }
      fromAxisAngle(t2, e2) {
        return function(t3, e3, i2) {
          i2 *= 0.5;
          let s2 = Math.sin(i2);
          t3[0] = s2 * e3[0], t3[1] = s2 * e3[1], t3[2] = s2 * e3[2], t3[3] = Math.cos(i2);
        }(this, t2, e2), this;
      }
      slerp(t2, e2) {
        return function(t3, e3, i2, s2) {
          let r2, n2, a2, o2, h2, l2 = e3[0], c2 = e3[1], u2 = e3[2], g2 = e3[3], d2 = i2[0], m2 = i2[1], p2 = i2[2], x2 = i2[3];
          n2 = l2 * d2 + c2 * m2 + u2 * p2 + g2 * x2, n2 < 0 && (n2 = -n2, d2 = -d2, m2 = -m2, p2 = -p2, x2 = -x2), 1 - n2 > 1e-6 ? (r2 = Math.acos(n2), a2 = Math.sin(r2), o2 = Math.sin((1 - s2) * r2) / a2, h2 = Math.sin(s2 * r2) / a2) : (o2 = 1 - s2, h2 = s2), t3[0] = o2 * l2 + h2 * d2, t3[1] = o2 * c2 + h2 * m2, t3[2] = o2 * u2 + h2 * p2, t3[3] = o2 * g2 + h2 * x2;
        }(this, this, t2, e2), this;
      }
      fromArray(t2, e2 = 0) {
        return this[0] = t2[e2], this[1] = t2[e2 + 1], this[2] = t2[e2 + 2], this[3] = t2[e2 + 3], this;
      }
      toArray(t2 = [], e2 = 0) {
        return t2[e2] = this[0], t2[e2 + 1] = this[1], t2[e2 + 2] = this[2], t2[e2 + 3] = this[3], t2;
      }
    }
    function K(t2, e2, i2) {
      let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = e2[3], o2 = e2[4], h2 = e2[5], l2 = e2[6], c2 = e2[7], u2 = e2[8], g2 = e2[9], d2 = e2[10], m2 = e2[11], p2 = e2[12], x2 = e2[13], f2 = e2[14], v2 = e2[15], A2 = i2[0], M2 = i2[1], w2 = i2[2], y2 = i2[3];
      return t2[0] = A2 * s2 + M2 * o2 + w2 * u2 + y2 * p2, t2[1] = A2 * r2 + M2 * h2 + w2 * g2 + y2 * x2, t2[2] = A2 * n2 + M2 * l2 + w2 * d2 + y2 * f2, t2[3] = A2 * a2 + M2 * c2 + w2 * m2 + y2 * v2, A2 = i2[4], M2 = i2[5], w2 = i2[6], y2 = i2[7], t2[4] = A2 * s2 + M2 * o2 + w2 * u2 + y2 * p2, t2[5] = A2 * r2 + M2 * h2 + w2 * g2 + y2 * x2, t2[6] = A2 * n2 + M2 * l2 + w2 * d2 + y2 * f2, t2[7] = A2 * a2 + M2 * c2 + w2 * m2 + y2 * v2, A2 = i2[8], M2 = i2[9], w2 = i2[10], y2 = i2[11], t2[8] = A2 * s2 + M2 * o2 + w2 * u2 + y2 * p2, t2[9] = A2 * r2 + M2 * h2 + w2 * g2 + y2 * x2, t2[10] = A2 * n2 + M2 * l2 + w2 * d2 + y2 * f2, t2[11] = A2 * a2 + M2 * c2 + w2 * m2 + y2 * v2, A2 = i2[12], M2 = i2[13], w2 = i2[14], y2 = i2[15], t2[12] = A2 * s2 + M2 * o2 + w2 * u2 + y2 * p2, t2[13] = A2 * r2 + M2 * h2 + w2 * g2 + y2 * x2, t2[14] = A2 * n2 + M2 * l2 + w2 * d2 + y2 * f2, t2[15] = A2 * a2 + M2 * c2 + w2 * m2 + y2 * v2, t2;
    }
    function k(t2, e2) {
      let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[4], a2 = e2[5], o2 = e2[6], h2 = e2[8], l2 = e2[9], c2 = e2[10];
      return t2[0] = Math.hypot(i2, s2, r2), t2[1] = Math.hypot(n2, a2, o2), t2[2] = Math.hypot(h2, l2, c2), t2;
    }
    const Q = function() {
      const t2 = [0, 0, 0];
      return function(e2, i2) {
        let s2 = t2;
        k(s2, i2);
        let r2 = 1 / s2[0], n2 = 1 / s2[1], a2 = 1 / s2[2], o2 = i2[0] * r2, h2 = i2[1] * n2, l2 = i2[2] * a2, c2 = i2[4] * r2, u2 = i2[5] * n2, g2 = i2[6] * a2, d2 = i2[8] * r2, m2 = i2[9] * n2, p2 = i2[10] * a2, x2 = o2 + u2 + p2, f2 = 0;
        return x2 > 0 ? (f2 = 2 * Math.sqrt(x2 + 1), e2[3] = 0.25 * f2, e2[0] = (g2 - m2) / f2, e2[1] = (d2 - l2) / f2, e2[2] = (h2 - c2) / f2) : o2 > u2 && o2 > p2 ? (f2 = 2 * Math.sqrt(1 + o2 - u2 - p2), e2[3] = (g2 - m2) / f2, e2[0] = 0.25 * f2, e2[1] = (h2 + c2) / f2, e2[2] = (d2 + l2) / f2) : u2 > p2 ? (f2 = 2 * Math.sqrt(1 + u2 - o2 - p2), e2[3] = (d2 - l2) / f2, e2[0] = (h2 + c2) / f2, e2[1] = 0.25 * f2, e2[2] = (g2 + m2) / f2) : (f2 = 2 * Math.sqrt(1 + p2 - o2 - u2), e2[3] = (h2 - c2) / f2, e2[0] = (d2 + l2) / f2, e2[1] = (g2 + m2) / f2, e2[2] = 0.25 * f2), e2;
      };
    }();
    class N extends Array {
      constructor(t2 = 1, e2 = 0, i2 = 0, s2 = 0, r2 = 0, n2 = 1, a2 = 0, o2 = 0, h2 = 0, l2 = 0, c2 = 1, u2 = 0, g2 = 0, d2 = 0, m2 = 0, p2 = 1) {
        return super(t2, e2, i2, s2, r2, n2, a2, o2, h2, l2, c2, u2, g2, d2, m2, p2), this;
      }
      get x() {
        return this[12];
      }
      get y() {
        return this[13];
      }
      get z() {
        return this[14];
      }
      get w() {
        return this[15];
      }
      set x(t2) {
        this[12] = t2;
      }
      set y(t2) {
        this[13] = t2;
      }
      set z(t2) {
        this[14] = t2;
      }
      set w(t2) {
        this[15] = t2;
      }
      set(t2, e2, i2, s2, r2, n2, a2, o2, h2, l2, c2, u2, g2, d2, m2, p2) {
        return t2.length ? this.copy(t2) : (function(t3, e3, i3, s3, r3, n3, a3, o3, h3, l3, c3, u3, g3, d3, m3, p3, x2) {
          t3[0] = e3, t3[1] = i3, t3[2] = s3, t3[3] = r3, t3[4] = n3, t3[5] = a3, t3[6] = o3, t3[7] = h3, t3[8] = l3, t3[9] = c3, t3[10] = u3, t3[11] = g3, t3[12] = d3, t3[13] = m3, t3[14] = p3, t3[15] = x2;
        }(this, t2, e2, i2, s2, r2, n2, a2, o2, h2, l2, c2, u2, g2, d2, m2, p2), this);
      }
      translate(t2, e2 = this) {
        return function(t3, e3, i2) {
          let s2, r2, n2, a2, o2, h2, l2, c2, u2, g2, d2, m2, p2 = i2[0], x2 = i2[1], f2 = i2[2];
          e3 === t3 ? (t3[12] = e3[0] * p2 + e3[4] * x2 + e3[8] * f2 + e3[12], t3[13] = e3[1] * p2 + e3[5] * x2 + e3[9] * f2 + e3[13], t3[14] = e3[2] * p2 + e3[6] * x2 + e3[10] * f2 + e3[14], t3[15] = e3[3] * p2 + e3[7] * x2 + e3[11] * f2 + e3[15]) : (s2 = e3[0], r2 = e3[1], n2 = e3[2], a2 = e3[3], o2 = e3[4], h2 = e3[5], l2 = e3[6], c2 = e3[7], u2 = e3[8], g2 = e3[9], d2 = e3[10], m2 = e3[11], t3[0] = s2, t3[1] = r2, t3[2] = n2, t3[3] = a2, t3[4] = o2, t3[5] = h2, t3[6] = l2, t3[7] = c2, t3[8] = u2, t3[9] = g2, t3[10] = d2, t3[11] = m2, t3[12] = s2 * p2 + o2 * x2 + u2 * f2 + e3[12], t3[13] = r2 * p2 + h2 * x2 + g2 * f2 + e3[13], t3[14] = n2 * p2 + l2 * x2 + d2 * f2 + e3[14], t3[15] = a2 * p2 + c2 * x2 + m2 * f2 + e3[15]);
        }(this, e2, t2), this;
      }
      rotate(t2, e2, i2 = this) {
        return function(t3, e3, i3, s2) {
          let r2, n2, a2, o2, h2, l2, c2, u2, g2, d2, m2, p2, x2, f2, v2, A2, M2, w2, y2, E2, U2, F2, C2, R2, b2 = s2[0], T2 = s2[1], I2 = s2[2], G2 = Math.hypot(b2, T2, I2);
          Math.abs(G2) < 1e-6 || (G2 = 1 / G2, b2 *= G2, T2 *= G2, I2 *= G2, r2 = Math.sin(i3), n2 = Math.cos(i3), a2 = 1 - n2, o2 = e3[0], h2 = e3[1], l2 = e3[2], c2 = e3[3], u2 = e3[4], g2 = e3[5], d2 = e3[6], m2 = e3[7], p2 = e3[8], x2 = e3[9], f2 = e3[10], v2 = e3[11], A2 = b2 * b2 * a2 + n2, M2 = T2 * b2 * a2 + I2 * r2, w2 = I2 * b2 * a2 - T2 * r2, y2 = b2 * T2 * a2 - I2 * r2, E2 = T2 * T2 * a2 + n2, U2 = I2 * T2 * a2 + b2 * r2, F2 = b2 * I2 * a2 + T2 * r2, C2 = T2 * I2 * a2 - b2 * r2, R2 = I2 * I2 * a2 + n2, t3[0] = o2 * A2 + u2 * M2 + p2 * w2, t3[1] = h2 * A2 + g2 * M2 + x2 * w2, t3[2] = l2 * A2 + d2 * M2 + f2 * w2, t3[3] = c2 * A2 + m2 * M2 + v2 * w2, t3[4] = o2 * y2 + u2 * E2 + p2 * U2, t3[5] = h2 * y2 + g2 * E2 + x2 * U2, t3[6] = l2 * y2 + d2 * E2 + f2 * U2, t3[7] = c2 * y2 + m2 * E2 + v2 * U2, t3[8] = o2 * F2 + u2 * C2 + p2 * R2, t3[9] = h2 * F2 + g2 * C2 + x2 * R2, t3[10] = l2 * F2 + d2 * C2 + f2 * R2, t3[11] = c2 * F2 + m2 * C2 + v2 * R2, e3 !== t3 && (t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]));
        }(this, i2, t2, e2), this;
      }
      scale(t2, e2 = this) {
        return function(t3, e3, i2) {
          let s2 = i2[0], r2 = i2[1], n2 = i2[2];
          t3[0] = e3[0] * s2, t3[1] = e3[1] * s2, t3[2] = e3[2] * s2, t3[3] = e3[3] * s2, t3[4] = e3[4] * r2, t3[5] = e3[5] * r2, t3[6] = e3[6] * r2, t3[7] = e3[7] * r2, t3[8] = e3[8] * n2, t3[9] = e3[9] * n2, t3[10] = e3[10] * n2, t3[11] = e3[11] * n2, t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15];
        }(this, e2, "number" == typeof t2 ? [t2, t2, t2] : t2), this;
      }
      multiply(t2, e2) {
        return e2 ? K(this, t2, e2) : K(this, this, t2), this;
      }
      identity() {
        var t2;
        return (t2 = this)[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
      }
      copy(t2) {
        var e2, i2;
        return i2 = t2, (e2 = this)[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], e2[9] = i2[9], e2[10] = i2[10], e2[11] = i2[11], e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], e2[15] = i2[15], this;
      }
      fromPerspective({ fov: t2, aspect: e2, near: i2, far: s2 } = {}) {
        return function(t3, e3, i3, s3, r2) {
          let n2 = 1 / Math.tan(e3 / 2), a2 = 1 / (s3 - r2);
          t3[0] = n2 / i3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = n2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = (r2 + s3) * a2, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = 2 * r2 * s3 * a2, t3[15] = 0;
        }(this, t2, e2, i2, s2), this;
      }
      fromOrthogonal({ left: t2, right: e2, bottom: i2, top: s2, near: r2, far: n2 }) {
        return function(t3, e3, i3, s3, r3, n3, a2) {
          let o2 = 1 / (e3 - i3), h2 = 1 / (s3 - r3), l2 = 1 / (n3 - a2);
          t3[0] = -2 * o2, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * h2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * l2, t3[11] = 0, t3[12] = (e3 + i3) * o2, t3[13] = (r3 + s3) * h2, t3[14] = (a2 + n3) * l2, t3[15] = 1;
        }(this, t2, e2, i2, s2, r2, n2), this;
      }
      fromQuaternion(t2) {
        return function(t3, e2) {
          let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = i2 + i2, o2 = s2 + s2, h2 = r2 + r2, l2 = i2 * a2, c2 = s2 * a2, u2 = s2 * o2, g2 = r2 * a2, d2 = r2 * o2, m2 = r2 * h2, p2 = n2 * a2, x2 = n2 * o2, f2 = n2 * h2;
          t3[0] = 1 - u2 - m2, t3[1] = c2 + f2, t3[2] = g2 - x2, t3[3] = 0, t3[4] = c2 - f2, t3[5] = 1 - l2 - m2, t3[6] = d2 + p2, t3[7] = 0, t3[8] = g2 + x2, t3[9] = d2 - p2, t3[10] = 1 - l2 - u2, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1;
        }(this, t2), this;
      }
      setPosition(t2) {
        return this.x = t2[0], this.y = t2[1], this.z = t2[2], this;
      }
      inverse(t2 = this) {
        return function(t3, e2) {
          let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = e2[4], o2 = e2[5], h2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = e2[9], g2 = e2[10], d2 = e2[11], m2 = e2[12], p2 = e2[13], x2 = e2[14], f2 = e2[15], v2 = i2 * o2 - s2 * a2, A2 = i2 * h2 - r2 * a2, M2 = i2 * l2 - n2 * a2, w2 = s2 * h2 - r2 * o2, y2 = s2 * l2 - n2 * o2, E2 = r2 * l2 - n2 * h2, U2 = c2 * p2 - u2 * m2, F2 = c2 * x2 - g2 * m2, C2 = c2 * f2 - d2 * m2, R2 = u2 * x2 - g2 * p2, b2 = u2 * f2 - d2 * p2, T2 = g2 * f2 - d2 * x2, I2 = v2 * T2 - A2 * b2 + M2 * R2 + w2 * C2 - y2 * F2 + E2 * U2;
          I2 && (I2 = 1 / I2, t3[0] = (o2 * T2 - h2 * b2 + l2 * R2) * I2, t3[1] = (r2 * b2 - s2 * T2 - n2 * R2) * I2, t3[2] = (p2 * E2 - x2 * y2 + f2 * w2) * I2, t3[3] = (g2 * y2 - u2 * E2 - d2 * w2) * I2, t3[4] = (h2 * C2 - a2 * T2 - l2 * F2) * I2, t3[5] = (i2 * T2 - r2 * C2 + n2 * F2) * I2, t3[6] = (x2 * M2 - m2 * E2 - f2 * A2) * I2, t3[7] = (c2 * E2 - g2 * M2 + d2 * A2) * I2, t3[8] = (a2 * b2 - o2 * C2 + l2 * U2) * I2, t3[9] = (s2 * C2 - i2 * b2 - n2 * U2) * I2, t3[10] = (m2 * y2 - p2 * M2 + f2 * v2) * I2, t3[11] = (u2 * M2 - c2 * y2 - d2 * v2) * I2, t3[12] = (o2 * F2 - a2 * R2 - h2 * U2) * I2, t3[13] = (i2 * R2 - s2 * F2 + r2 * U2) * I2, t3[14] = (p2 * A2 - m2 * w2 - x2 * v2) * I2, t3[15] = (c2 * w2 - u2 * A2 + g2 * v2) * I2);
        }(this, t2), this;
      }
      compose(t2, e2, i2) {
        return function(t3, e3, i3, s2) {
          let r2 = e3[0], n2 = e3[1], a2 = e3[2], o2 = e3[3], h2 = r2 + r2, l2 = n2 + n2, c2 = a2 + a2, u2 = r2 * h2, g2 = r2 * l2, d2 = r2 * c2, m2 = n2 * l2, p2 = n2 * c2, x2 = a2 * c2, f2 = o2 * h2, v2 = o2 * l2, A2 = o2 * c2, M2 = s2[0], w2 = s2[1], y2 = s2[2];
          t3[0] = (1 - (m2 + x2)) * M2, t3[1] = (g2 + A2) * M2, t3[2] = (d2 - v2) * M2, t3[3] = 0, t3[4] = (g2 - A2) * w2, t3[5] = (1 - (u2 + x2)) * w2, t3[6] = (p2 + f2) * w2, t3[7] = 0, t3[8] = (d2 + v2) * y2, t3[9] = (p2 - f2) * y2, t3[10] = (1 - (u2 + m2)) * y2, t3[11] = 0, t3[12] = i3[0], t3[13] = i3[1], t3[14] = i3[2], t3[15] = 1;
        }(this, t2, e2, i2), this;
      }
      getRotation(t2) {
        return Q(t2, this), this;
      }
      getTranslation(t2) {
        var e2, i2;
        return i2 = this, (e2 = t2)[0] = i2[12], e2[1] = i2[13], e2[2] = i2[14], this;
      }
      getScaling(t2) {
        return k(t2, this), this;
      }
      getMaxScaleOnAxis() {
        return function(t2) {
          let e2 = t2[0], i2 = t2[1], s2 = t2[2], r2 = t2[4], n2 = t2[5], a2 = t2[6], o2 = t2[8], h2 = t2[9], l2 = t2[10];
          const c2 = e2 * e2 + i2 * i2 + s2 * s2, u2 = r2 * r2 + n2 * n2 + a2 * a2, g2 = o2 * o2 + h2 * h2 + l2 * l2;
          return Math.sqrt(Math.max(c2, u2, g2));
        }(this);
      }
      lookAt(t2, e2, i2) {
        return function(t3, e3, i3, s2) {
          let r2 = e3[0], n2 = e3[1], a2 = e3[2], o2 = s2[0], h2 = s2[1], l2 = s2[2], c2 = r2 - i3[0], u2 = n2 - i3[1], g2 = a2 - i3[2], d2 = c2 * c2 + u2 * u2 + g2 * g2;
          0 === d2 ? g2 = 1 : (d2 = 1 / Math.sqrt(d2), c2 *= d2, u2 *= d2, g2 *= d2);
          let m2 = h2 * g2 - l2 * u2, p2 = l2 * c2 - o2 * g2, x2 = o2 * u2 - h2 * c2;
          d2 = m2 * m2 + p2 * p2 + x2 * x2, 0 === d2 && (l2 ? o2 += 1e-6 : h2 ? l2 += 1e-6 : h2 += 1e-6, m2 = h2 * g2 - l2 * u2, p2 = l2 * c2 - o2 * g2, x2 = o2 * u2 - h2 * c2, d2 = m2 * m2 + p2 * p2 + x2 * x2), d2 = 1 / Math.sqrt(d2), m2 *= d2, p2 *= d2, x2 *= d2, t3[0] = m2, t3[1] = p2, t3[2] = x2, t3[3] = 0, t3[4] = u2 * x2 - g2 * p2, t3[5] = g2 * m2 - c2 * x2, t3[6] = c2 * p2 - u2 * m2, t3[7] = 0, t3[8] = c2, t3[9] = u2, t3[10] = g2, t3[11] = 0, t3[12] = r2, t3[13] = n2, t3[14] = a2, t3[15] = 1;
        }(this, t2, e2, i2), this;
      }
      determinant() {
        return function(t2) {
          let e2 = t2[0], i2 = t2[1], s2 = t2[2], r2 = t2[3], n2 = t2[4], a2 = t2[5], o2 = t2[6], h2 = t2[7], l2 = t2[8], c2 = t2[9], u2 = t2[10], g2 = t2[11], d2 = t2[12], m2 = t2[13], p2 = t2[14], x2 = t2[15];
          return (e2 * a2 - i2 * n2) * (u2 * x2 - g2 * p2) - (e2 * o2 - s2 * n2) * (c2 * x2 - g2 * m2) + (e2 * h2 - r2 * n2) * (c2 * p2 - u2 * m2) + (i2 * o2 - s2 * a2) * (l2 * x2 - g2 * d2) - (i2 * h2 - r2 * a2) * (l2 * p2 - u2 * d2) + (s2 * h2 - r2 * o2) * (l2 * m2 - c2 * d2);
        }(this);
      }
      fromArray(t2, e2 = 0) {
        return this[0] = t2[e2], this[1] = t2[e2 + 1], this[2] = t2[e2 + 2], this[3] = t2[e2 + 3], this[4] = t2[e2 + 4], this[5] = t2[e2 + 5], this[6] = t2[e2 + 6], this[7] = t2[e2 + 7], this[8] = t2[e2 + 8], this[9] = t2[e2 + 9], this[10] = t2[e2 + 10], this[11] = t2[e2 + 11], this[12] = t2[e2 + 12], this[13] = t2[e2 + 13], this[14] = t2[e2 + 14], this[15] = t2[e2 + 15], this;
      }
      toArray(t2 = [], e2 = 0) {
        return t2[e2] = this[0], t2[e2 + 1] = this[1], t2[e2 + 2] = this[2], t2[e2 + 3] = this[3], t2[e2 + 4] = this[4], t2[e2 + 5] = this[5], t2[e2 + 6] = this[6], t2[e2 + 7] = this[7], t2[e2 + 8] = this[8], t2[e2 + 9] = this[9], t2[e2 + 10] = this[10], t2[e2 + 11] = this[11], t2[e2 + 12] = this[12], t2[e2 + 13] = this[13], t2[e2 + 14] = this[14], t2[e2 + 15] = this[15], t2;
      }
    }
    const P = new N();
    class j extends Array {
      constructor(t2 = 0, e2 = t2, i2 = t2, s2 = "YXZ") {
        return super(t2, e2, i2), this.order = s2, this.onChange = () => {
        }, this;
      }
      get x() {
        return this[0];
      }
      get y() {
        return this[1];
      }
      get z() {
        return this[2];
      }
      set x(t2) {
        this[0] = t2, this.onChange();
      }
      set y(t2) {
        this[1] = t2, this.onChange();
      }
      set z(t2) {
        this[2] = t2, this.onChange();
      }
      set(t2, e2 = t2, i2 = t2) {
        return t2.length ? this.copy(t2) : (this[0] = t2, this[1] = e2, this[2] = i2, this.onChange(), this);
      }
      copy(t2) {
        return this[0] = t2[0], this[1] = t2[1], this[2] = t2[2], this.onChange(), this;
      }
      reorder(t2) {
        return this.order = t2, this.onChange(), this;
      }
      fromRotationMatrix(t2, e2 = this.order) {
        return function(t3, e3, i2 = "YXZ") {
          "XYZ" === i2 ? (t3[1] = Math.asin(Math.min(Math.max(e3[8], -1), 1)), Math.abs(e3[8]) < 0.99999 ? (t3[0] = Math.atan2(-e3[9], e3[10]), t3[2] = Math.atan2(-e3[4], e3[0])) : (t3[0] = Math.atan2(e3[6], e3[5]), t3[2] = 0)) : "YXZ" === i2 ? (t3[0] = Math.asin(-Math.min(Math.max(e3[9], -1), 1)), Math.abs(e3[9]) < 0.99999 ? (t3[1] = Math.atan2(e3[8], e3[10]), t3[2] = Math.atan2(e3[1], e3[5])) : (t3[1] = Math.atan2(-e3[2], e3[0]), t3[2] = 0)) : "ZXY" === i2 ? (t3[0] = Math.asin(Math.min(Math.max(e3[6], -1), 1)), Math.abs(e3[6]) < 0.99999 ? (t3[1] = Math.atan2(-e3[2], e3[10]), t3[2] = Math.atan2(-e3[4], e3[5])) : (t3[1] = 0, t3[2] = Math.atan2(e3[1], e3[0]))) : "ZYX" === i2 ? (t3[1] = Math.asin(-Math.min(Math.max(e3[2], -1), 1)), Math.abs(e3[2]) < 0.99999 ? (t3[0] = Math.atan2(e3[6], e3[10]), t3[2] = Math.atan2(e3[1], e3[0])) : (t3[0] = 0, t3[2] = Math.atan2(-e3[4], e3[5]))) : "YZX" === i2 ? (t3[2] = Math.asin(Math.min(Math.max(e3[1], -1), 1)), Math.abs(e3[1]) < 0.99999 ? (t3[0] = Math.atan2(-e3[9], e3[5]), t3[1] = Math.atan2(-e3[2], e3[0])) : (t3[0] = 0, t3[1] = Math.atan2(e3[8], e3[10]))) : "XZY" === i2 && (t3[2] = Math.asin(-Math.min(Math.max(e3[4], -1), 1)), Math.abs(e3[4]) < 0.99999 ? (t3[0] = Math.atan2(e3[6], e3[5]), t3[1] = Math.atan2(e3[8], e3[0])) : (t3[0] = Math.atan2(-e3[9], e3[10]), t3[1] = 0));
        }(this, t2, e2), this;
      }
      fromQuaternion(t2, e2 = this.order) {
        return P.fromQuaternion(t2), this.fromRotationMatrix(P, e2);
      }
      toArray(t2 = [], e2 = 0) {
        return t2[e2] = this[0], t2[e2 + 1] = this[1], t2[e2 + 2] = this[2], t2;
      }
    }
    class O {
      constructor() {
        this.parent = null, this.children = [], this.visible = true, this.matrix = new N(), this.worldMatrix = new N(), this.matrixAutoUpdate = true, this.position = new c(), this.quaternion = new D(), this.scale = new c(1), this.rotation = new j(), this.up = new c(0, 1, 0), this.rotation.onChange = () => this.quaternion.fromEuler(this.rotation), this.quaternion.onChange = () => this.rotation.fromQuaternion(this.quaternion);
      }
      setParent(t2, e2 = true) {
        this.parent && t2 !== this.parent && this.parent.removeChild(this, false), this.parent = t2, e2 && t2 && t2.addChild(this, false);
      }
      addChild(t2, e2 = true) {
        ~this.children.indexOf(t2) || this.children.push(t2), e2 && t2.setParent(this, false);
      }
      removeChild(t2, e2 = true) {
        ~this.children.indexOf(t2) && this.children.splice(this.children.indexOf(t2), 1), e2 && t2.setParent(null, false);
      }
      updateMatrixWorld(t2) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.worldMatrixNeedsUpdate || t2) && (null === this.parent ? this.worldMatrix.copy(this.matrix) : this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix), this.worldMatrixNeedsUpdate = false, t2 = true);
        for (let e2 = 0, i2 = this.children.length; e2 < i2; e2++)
          this.children[e2].updateMatrixWorld(t2);
      }
      updateMatrix() {
        this.matrix.compose(this.quaternion, this.position, this.scale), this.worldMatrixNeedsUpdate = true;
      }
      traverse(t2) {
        if (!t2(this))
          for (let e2 = 0, i2 = this.children.length; e2 < i2; e2++)
            this.children[e2].traverse(t2);
      }
      decompose() {
        this.matrix.getTranslation(this.position), this.matrix.getRotation(this.quaternion), this.matrix.getScaling(this.scale), this.rotation.fromQuaternion(this.quaternion);
      }
      lookAt(t2, e2 = false) {
        e2 ? this.matrix.lookAt(this.position, t2, this.up) : this.matrix.lookAt(t2, this.position, this.up), this.matrix.getRotation(this.quaternion), this.rotation.fromQuaternion(this.quaternion);
      }
    }
    const V = new N(), z = new c(), Z = new c();
    class J extends O {
      constructor(t2, { near: e2 = 0.1, far: i2 = 100, fov: s2 = 45, aspect: r2 = 1, left: n2, right: a2, bottom: o2, top: h2, zoom: l2 = 1 } = {}) {
        super(), Object.assign(this, { near: e2, far: i2, fov: s2, aspect: r2, left: n2, right: a2, bottom: o2, top: h2, zoom: l2 }), this.projectionMatrix = new N(), this.viewMatrix = new N(), this.projectionViewMatrix = new N(), this.worldPosition = new c(), this.type = n2 || a2 ? "orthographic" : "perspective", "orthographic" === this.type ? this.orthographic() : this.perspective();
      }
      perspective({ near: t2 = this.near, far: e2 = this.far, fov: i2 = this.fov, aspect: s2 = this.aspect } = {}) {
        return Object.assign(this, { near: t2, far: e2, fov: i2, aspect: s2 }), this.projectionMatrix.fromPerspective({ fov: i2 * (Math.PI / 180), aspect: s2, near: t2, far: e2 }), this.type = "perspective", this;
      }
      orthographic({ near: t2 = this.near, far: e2 = this.far, left: i2 = this.left, right: s2 = this.right, bottom: r2 = this.bottom, top: n2 = this.top, zoom: a2 = this.zoom } = {}) {
        return Object.assign(this, { near: t2, far: e2, left: i2, right: s2, bottom: r2, top: n2, zoom: a2 }), i2 /= a2, s2 /= a2, r2 /= a2, n2 /= a2, this.projectionMatrix.fromOrthogonal({ left: i2, right: s2, bottom: r2, top: n2, near: t2, far: e2 }), this.type = "orthographic", this;
      }
      updateMatrixWorld() {
        return super.updateMatrixWorld(), this.viewMatrix.inverse(this.worldMatrix), this.worldMatrix.getTranslation(this.worldPosition), this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix), this;
      }
      lookAt(t2) {
        return super.lookAt(t2, true), this;
      }
      project(t2) {
        return t2.applyMatrix4(this.viewMatrix), t2.applyMatrix4(this.projectionMatrix), this;
      }
      unproject(t2) {
        return t2.applyMatrix4(V.inverse(this.projectionMatrix)), t2.applyMatrix4(this.worldMatrix), this;
      }
      updateFrustum() {
        this.frustum || (this.frustum = [new c(), new c(), new c(), new c(), new c(), new c()]);
        const t2 = this.projectionViewMatrix;
        this.frustum[0].set(t2[3] - t2[0], t2[7] - t2[4], t2[11] - t2[8]).constant = t2[15] - t2[12], this.frustum[1].set(t2[3] + t2[0], t2[7] + t2[4], t2[11] + t2[8]).constant = t2[15] + t2[12], this.frustum[2].set(t2[3] + t2[1], t2[7] + t2[5], t2[11] + t2[9]).constant = t2[15] + t2[13], this.frustum[3].set(t2[3] - t2[1], t2[7] - t2[5], t2[11] - t2[9]).constant = t2[15] - t2[13], this.frustum[4].set(t2[3] - t2[2], t2[7] - t2[6], t2[11] - t2[10]).constant = t2[15] - t2[14], this.frustum[5].set(t2[3] + t2[2], t2[7] + t2[6], t2[11] + t2[10]).constant = t2[15] + t2[14];
        for (let t3 = 0; t3 < 6; t3++) {
          const e2 = 1 / this.frustum[t3].distance();
          this.frustum[t3].multiply(e2), this.frustum[t3].constant *= e2;
        }
      }
      frustumIntersectsMesh(t2) {
        if (!t2.geometry.attributes.position)
          return true;
        if (t2.geometry.bounds && t2.geometry.bounds.radius !== 1 / 0 || t2.geometry.computeBoundingSphere(), !t2.geometry.bounds)
          return true;
        const e2 = z;
        e2.copy(t2.geometry.bounds.center), e2.applyMatrix4(t2.worldMatrix);
        const i2 = t2.geometry.bounds.radius * t2.worldMatrix.getMaxScaleOnAxis();
        return this.frustumIntersectsSphere(e2, i2);
      }
      frustumIntersectsSphere(t2, e2) {
        const i2 = Z;
        for (let s2 = 0; s2 < 6; s2++) {
          const r2 = this.frustum[s2];
          if (i2.copy(r2).dot(t2) + r2.constant < -e2)
            return false;
        }
        return true;
      }
    }
    function L(t2, e2, i2) {
      let s2 = e2[0], r2 = e2[1], n2 = e2[2], a2 = e2[3], o2 = e2[4], h2 = e2[5], l2 = e2[6], c2 = e2[7], u2 = e2[8], g2 = i2[0], d2 = i2[1], m2 = i2[2], p2 = i2[3], x2 = i2[4], f2 = i2[5], v2 = i2[6], A2 = i2[7], M2 = i2[8];
      return t2[0] = g2 * s2 + d2 * a2 + m2 * l2, t2[1] = g2 * r2 + d2 * o2 + m2 * c2, t2[2] = g2 * n2 + d2 * h2 + m2 * u2, t2[3] = p2 * s2 + x2 * a2 + f2 * l2, t2[4] = p2 * r2 + x2 * o2 + f2 * c2, t2[5] = p2 * n2 + x2 * h2 + f2 * u2, t2[6] = v2 * s2 + A2 * a2 + M2 * l2, t2[7] = v2 * r2 + A2 * o2 + M2 * c2, t2[8] = v2 * n2 + A2 * h2 + M2 * u2, t2;
    }
    class H extends Array {
      constructor(t2 = 1, e2 = 0, i2 = 0, s2 = 0, r2 = 1, n2 = 0, a2 = 0, o2 = 0, h2 = 1) {
        return super(t2, e2, i2, s2, r2, n2, a2, o2, h2), this;
      }
      set(t2, e2, i2, s2, r2, n2, a2, o2, h2) {
        return t2.length ? this.copy(t2) : (function(t3, e3, i3, s3, r3, n3, a3, o3, h3, l2) {
          t3[0] = e3, t3[1] = i3, t3[2] = s3, t3[3] = r3, t3[4] = n3, t3[5] = a3, t3[6] = o3, t3[7] = h3, t3[8] = l2;
        }(this, t2, e2, i2, s2, r2, n2, a2, o2, h2), this);
      }
      translate(t2, e2 = this) {
        return function(t3, e3, i2) {
          let s2 = e3[0], r2 = e3[1], n2 = e3[2], a2 = e3[3], o2 = e3[4], h2 = e3[5], l2 = e3[6], c2 = e3[7], u2 = e3[8], g2 = i2[0], d2 = i2[1];
          t3[0] = s2, t3[1] = r2, t3[2] = n2, t3[3] = a2, t3[4] = o2, t3[5] = h2, t3[6] = g2 * s2 + d2 * a2 + l2, t3[7] = g2 * r2 + d2 * o2 + c2, t3[8] = g2 * n2 + d2 * h2 + u2;
        }(this, e2, t2), this;
      }
      rotate(t2, e2 = this) {
        return function(t3, e3, i2) {
          let s2 = e3[0], r2 = e3[1], n2 = e3[2], a2 = e3[3], o2 = e3[4], h2 = e3[5], l2 = e3[6], c2 = e3[7], u2 = e3[8], g2 = Math.sin(i2), d2 = Math.cos(i2);
          t3[0] = d2 * s2 + g2 * a2, t3[1] = d2 * r2 + g2 * o2, t3[2] = d2 * n2 + g2 * h2, t3[3] = d2 * a2 - g2 * s2, t3[4] = d2 * o2 - g2 * r2, t3[5] = d2 * h2 - g2 * n2, t3[6] = l2, t3[7] = c2, t3[8] = u2;
        }(this, e2, t2), this;
      }
      scale(t2, e2 = this) {
        return function(t3, e3, i2) {
          let s2 = i2[0], r2 = i2[1];
          t3[0] = s2 * e3[0], t3[1] = s2 * e3[1], t3[2] = s2 * e3[2], t3[3] = r2 * e3[3], t3[4] = r2 * e3[4], t3[5] = r2 * e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8];
        }(this, e2, t2), this;
      }
      multiply(t2, e2) {
        return e2 ? L(this, t2, e2) : L(this, this, t2), this;
      }
      identity() {
        var t2;
        return (t2 = this)[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, this;
      }
      copy(t2) {
        var e2, i2;
        return i2 = t2, (e2 = this)[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], this;
      }
      fromMatrix4(t2) {
        var e2, i2;
        return i2 = t2, (e2 = this)[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[4], e2[4] = i2[5], e2[5] = i2[6], e2[6] = i2[8], e2[7] = i2[9], e2[8] = i2[10], this;
      }
      fromQuaternion(t2) {
        return function(t3, e2) {
          let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = i2 + i2, o2 = s2 + s2, h2 = r2 + r2, l2 = i2 * a2, c2 = s2 * a2, u2 = s2 * o2, g2 = r2 * a2, d2 = r2 * o2, m2 = r2 * h2, p2 = n2 * a2, x2 = n2 * o2, f2 = n2 * h2;
          t3[0] = 1 - u2 - m2, t3[3] = c2 - f2, t3[6] = g2 + x2, t3[1] = c2 + f2, t3[4] = 1 - l2 - m2, t3[7] = d2 - p2, t3[2] = g2 - x2, t3[5] = d2 + p2, t3[8] = 1 - l2 - u2;
        }(this, t2), this;
      }
      fromBasis(t2, e2, i2) {
        return this.set(t2[0], t2[1], t2[2], e2[0], e2[1], e2[2], i2[0], i2[1], i2[2]), this;
      }
      inverse(t2 = this) {
        return function(t3, e2) {
          let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = e2[4], o2 = e2[5], h2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = c2 * a2 - o2 * l2, g2 = -c2 * n2 + o2 * h2, d2 = l2 * n2 - a2 * h2, m2 = i2 * u2 + s2 * g2 + r2 * d2;
          m2 && (m2 = 1 / m2, t3[0] = u2 * m2, t3[1] = (-c2 * s2 + r2 * l2) * m2, t3[2] = (o2 * s2 - r2 * a2) * m2, t3[3] = g2 * m2, t3[4] = (c2 * i2 - r2 * h2) * m2, t3[5] = (-o2 * i2 + r2 * n2) * m2, t3[6] = d2 * m2, t3[7] = (-l2 * i2 + s2 * h2) * m2, t3[8] = (a2 * i2 - s2 * n2) * m2);
        }(this, t2), this;
      }
      getNormalMatrix(t2) {
        return function(t3, e2) {
          let i2 = e2[0], s2 = e2[1], r2 = e2[2], n2 = e2[3], a2 = e2[4], o2 = e2[5], h2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = e2[9], g2 = e2[10], d2 = e2[11], m2 = e2[12], p2 = e2[13], x2 = e2[14], f2 = e2[15], v2 = i2 * o2 - s2 * a2, A2 = i2 * h2 - r2 * a2, M2 = i2 * l2 - n2 * a2, w2 = s2 * h2 - r2 * o2, y2 = s2 * l2 - n2 * o2, E2 = r2 * l2 - n2 * h2, U2 = c2 * p2 - u2 * m2, F2 = c2 * x2 - g2 * m2, C2 = c2 * f2 - d2 * m2, R2 = u2 * x2 - g2 * p2, b2 = u2 * f2 - d2 * p2, T2 = g2 * f2 - d2 * x2, I2 = v2 * T2 - A2 * b2 + M2 * R2 + w2 * C2 - y2 * F2 + E2 * U2;
          I2 && (I2 = 1 / I2, t3[0] = (o2 * T2 - h2 * b2 + l2 * R2) * I2, t3[1] = (h2 * C2 - a2 * T2 - l2 * F2) * I2, t3[2] = (a2 * b2 - o2 * C2 + l2 * U2) * I2, t3[3] = (r2 * b2 - s2 * T2 - n2 * R2) * I2, t3[4] = (i2 * T2 - r2 * C2 + n2 * F2) * I2, t3[5] = (s2 * C2 - i2 * b2 - n2 * U2) * I2, t3[6] = (p2 * E2 - x2 * y2 + f2 * w2) * I2, t3[7] = (x2 * M2 - m2 * E2 - f2 * A2) * I2, t3[8] = (m2 * y2 - p2 * M2 + f2 * v2) * I2);
        }(this, t2), this;
      }
    }
    let W = 0;
    class q extends O {
      constructor(t2, { geometry: e2, program: i2, mode: s2 = t2.TRIANGLES, frustumCulled: r2 = true, renderOrder: n2 = 0 } = {}) {
        super(), t2.canvas || console.error("gl not passed as first argument to Mesh"), this.gl = t2, this.id = W++, this.geometry = e2, this.program = i2, this.mode = s2, this.frustumCulled = r2, this.renderOrder = n2, this.modelViewMatrix = new N(), this.normalMatrix = new H(), this.beforeRenderCallbacks = [], this.afterRenderCallbacks = [];
      }
      onBeforeRender(t2) {
        return this.beforeRenderCallbacks.push(t2), this;
      }
      onAfterRender(t2) {
        return this.afterRenderCallbacks.push(t2), this;
      }
      draw({ camera: t2 } = {}) {
        this.beforeRenderCallbacks.forEach((e3) => e3 && e3({ mesh: this, camera: t2 })), t2 && (this.program.uniforms.modelMatrix || Object.assign(this.program.uniforms, { modelMatrix: { value: null }, viewMatrix: { value: null }, modelViewMatrix: { value: null }, normalMatrix: { value: null }, projectionMatrix: { value: null }, cameraPosition: { value: null } }), this.program.uniforms.projectionMatrix.value = t2.projectionMatrix, this.program.uniforms.cameraPosition.value = t2.worldPosition, this.program.uniforms.viewMatrix.value = t2.viewMatrix, this.modelViewMatrix.multiply(t2.viewMatrix, this.worldMatrix), this.normalMatrix.getNormalMatrix(this.modelViewMatrix), this.program.uniforms.modelMatrix.value = this.worldMatrix, this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix, this.program.uniforms.normalMatrix.value = this.normalMatrix);
        let e2 = this.program.cullFace && this.worldMatrix.determinant() < 0;
        this.program.use({ flipFaces: e2 }), this.geometry.draw({ mode: this.mode, program: this.program }), this.afterRenderCallbacks.forEach((e3) => e3 && e3({ mesh: this, camera: t2 }));
      }
    }
    const X = new Uint8Array(4);
    function _(t2) {
      return 0 == (t2 & t2 - 1);
    }
    let $ = 1;
    class tt {
      constructor(t2, { image: e2, target: i2 = t2.TEXTURE_2D, type: s2 = t2.UNSIGNED_BYTE, format: r2 = t2.RGBA, internalFormat: n2 = r2, wrapS: a2 = t2.CLAMP_TO_EDGE, wrapT: o2 = t2.CLAMP_TO_EDGE, generateMipmaps: h2 = true, minFilter: l2 = h2 ? t2.NEAREST_MIPMAP_LINEAR : t2.LINEAR, magFilter: c2 = t2.LINEAR, premultiplyAlpha: u2 = false, unpackAlignment: g2 = 4, flipY: d2 = i2 == t2.TEXTURE_2D, anisotropy: m2 = 0, level: p2 = 0, width: x2, height: f2 = x2 } = {}) {
        this.gl = t2, this.id = $++, this.image = e2, this.target = i2, this.type = s2, this.format = r2, this.internalFormat = n2, this.minFilter = l2, this.magFilter = c2, this.wrapS = a2, this.wrapT = o2, this.generateMipmaps = h2, this.premultiplyAlpha = u2, this.unpackAlignment = g2, this.flipY = d2, this.anisotropy = Math.min(m2, this.gl.renderer.parameters.maxAnisotropy), this.level = p2, this.width = x2, this.height = f2, this.texture = this.gl.createTexture(), this.store = { image: null }, this.glState = this.gl.renderer.state, this.state = {}, this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR, this.state.magFilter = this.gl.LINEAR, this.state.wrapS = this.gl.REPEAT, this.state.wrapT = this.gl.REPEAT, this.state.anisotropy = 0;
      }
      bind() {
        this.glState.textureUnits[this.glState.activeTextureUnit] !== this.id && (this.gl.bindTexture(this.target, this.texture), this.glState.textureUnits[this.glState.activeTextureUnit] = this.id);
      }
      update(t2 = 0) {
        const e2 = !(this.image === this.store.image && !this.needsUpdate);
        if ((e2 || this.glState.textureUnits[t2] !== this.id) && (this.gl.renderer.activeTexture(t2), this.bind()), e2) {
          if (this.needsUpdate = false, this.flipY !== this.glState.flipY && (this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY), this.glState.flipY = this.flipY), this.premultiplyAlpha !== this.glState.premultiplyAlpha && (this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha), this.glState.premultiplyAlpha = this.premultiplyAlpha), this.unpackAlignment !== this.glState.unpackAlignment && (this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment), this.glState.unpackAlignment = this.unpackAlignment), this.minFilter !== this.state.minFilter && (this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter), this.state.minFilter = this.minFilter), this.magFilter !== this.state.magFilter && (this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter), this.state.magFilter = this.magFilter), this.wrapS !== this.state.wrapS && (this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS), this.state.wrapS = this.wrapS), this.wrapT !== this.state.wrapT && (this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT), this.state.wrapT = this.wrapT), this.anisotropy && this.anisotropy !== this.state.anisotropy && (this.gl.texParameterf(this.target, this.gl.renderer.getExtension("EXT_texture_filter_anisotropic").TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy), this.state.anisotropy = this.anisotropy), this.image) {
            if (this.image.width && (this.width = this.image.width, this.height = this.image.height), this.target === this.gl.TEXTURE_CUBE_MAP)
              for (let t3 = 0; t3 < 6; t3++)
                this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + t3, this.level, this.internalFormat, this.format, this.type, this.image[t3]);
            else if (ArrayBuffer.isView(this.image))
              this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);
            else if (this.image.isCompressedTexture)
              for (let t3 = 0; t3 < this.image.length; t3++)
                this.gl.compressedTexImage2D(this.target, t3, this.internalFormat, this.image[t3].width, this.image[t3].height, 0, this.image[t3].data);
            else
              this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);
            this.generateMipmaps && (this.gl.renderer.isWebgl2 || _(this.image.width) && _(this.image.height) ? this.gl.generateMipmap(this.target) : (this.generateMipmaps = false, this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE, this.minFilter = this.gl.LINEAR)), this.onUpdate && this.onUpdate();
          } else if (this.target === this.gl.TEXTURE_CUBE_MAP)
            for (let t3 = 0; t3 < 6; t3++)
              this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + t3, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, X);
          else
            this.width ? this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null) : this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, X);
          this.store.image = this.image;
        }
      }
    }
    class et extends Array {
      constructor(t2 = 0, e2 = t2, i2 = t2, s2 = t2) {
        return super(t2, e2, i2, s2), this;
      }
      get x() {
        return this[0];
      }
      get y() {
        return this[1];
      }
      get z() {
        return this[2];
      }
      get w() {
        return this[3];
      }
      set x(t2) {
        this[0] = t2;
      }
      set y(t2) {
        this[1] = t2;
      }
      set z(t2) {
        this[2] = t2;
      }
      set w(t2) {
        this[3] = t2;
      }
      set(t2, e2, i2, s2) {
        return t2.length ? this.copy(t2) : (R(this, t2, e2, i2, s2), this);
      }
      copy(t2) {
        return C(this, t2), this;
      }
      normalize() {
        return b(this, this), this;
      }
      multiply(t2) {
        var e2, i2, s2;
        return i2 = this, s2 = t2, (e2 = this)[0] = i2[0] * s2, e2[1] = i2[1] * s2, e2[2] = i2[2] * s2, e2[3] = i2[3] * s2, this;
      }
      dot(t2) {
        return T(this, t2);
      }
      fromArray(t2, e2 = 0) {
        return this[0] = t2[e2], this[1] = t2[e2 + 1], this[2] = t2[e2 + 2], this[3] = t2[e2 + 3], this;
      }
      toArray(t2 = [], e2 = 0) {
        return t2[e2] = this[0], t2[e2 + 1] = this[1], t2[e2 + 2] = this[2], t2[e2 + 3] = this[3], t2;
      }
    }
    class it extends p {
      constructor(t2, { width: e2 = 1, height: i2 = 1, widthSegments: s2 = 1, heightSegments: r2 = 1, attributes: n2 = {} } = {}) {
        const a2 = s2, o2 = r2, h2 = (a2 + 1) * (o2 + 1), l2 = a2 * o2 * 6, c2 = new Float32Array(3 * h2), u2 = new Float32Array(3 * h2), g2 = new Float32Array(2 * h2), d2 = l2 > 65536 ? new Uint32Array(l2) : new Uint16Array(l2);
        it.buildPlane(c2, u2, g2, d2, e2, i2, 0, a2, o2), Object.assign(n2, { position: { size: 3, data: c2 }, normal: { size: 3, data: u2 }, uv: { size: 2, data: g2 }, index: { data: d2 } }), super(t2, n2);
      }
      static buildPlane(t2, e2, i2, s2, r2, n2, a2, o2, h2, l2 = 0, c2 = 1, u2 = 2, g2 = 1, d2 = -1, m2 = 0, p2 = 0) {
        const x2 = m2, f2 = r2 / o2, v2 = n2 / h2;
        for (let A2 = 0; A2 <= h2; A2++) {
          let M2 = A2 * v2 - n2 / 2;
          for (let n3 = 0; n3 <= o2; n3++, m2++) {
            let v3 = n3 * f2 - r2 / 2;
            if (t2[3 * m2 + l2] = v3 * g2, t2[3 * m2 + c2] = M2 * d2, t2[3 * m2 + u2] = a2 / 2, e2[3 * m2 + l2] = 0, e2[3 * m2 + c2] = 0, e2[3 * m2 + u2] = a2 >= 0 ? 1 : -1, i2[2 * m2] = n3 / o2, i2[2 * m2 + 1] = 1 - A2 / h2, A2 === h2 || n3 === o2)
              continue;
            let w2 = x2 + n3 + A2 * (o2 + 1), y2 = x2 + n3 + (A2 + 1) * (o2 + 1), E2 = x2 + n3 + (A2 + 1) * (o2 + 1) + 1, U2 = x2 + n3 + A2 * (o2 + 1) + 1;
            s2[6 * p2] = w2, s2[6 * p2 + 1] = y2, s2[6 * p2 + 2] = U2, s2[6 * p2 + 3] = y2, s2[6 * p2 + 4] = E2, s2[6 * p2 + 5] = U2, p2++;
          }
        }
      }
    }
    const st = 0.5 * (Math.sqrt(3) - 1), rt = (3 - Math.sqrt(3)) / 6, nt = (t2) => 0 | Math.floor(t2), at = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]);
    function ot(t2) {
      return t2 * (0.5 - Math.random());
    }
    function ht(t2, e2) {
      return t2 + Math.random() * (e2 - t2);
    }
    const lt = function(t2 = Math.random) {
      const e2 = function(t3) {
        const e3 = 512, i3 = new Uint8Array(e3);
        for (let t4 = 0; t4 < e3 / 2; t4++)
          i3[t4] = t4;
        for (let s3 = 0; s3 < e3 / 2 - 1; s3++) {
          const e4 = s3 + ~~(t3() * (256 - s3)), r2 = i3[s3];
          i3[s3] = i3[e4], i3[e4] = r2;
        }
        for (let t4 = 256; t4 < e3; t4++)
          i3[t4] = i3[t4 - 256];
        return i3;
      }(t2), i2 = new Float64Array(e2).map((t3) => at[t3 % 12 * 2]), s2 = new Float64Array(e2).map((t3) => at[t3 % 12 * 2 + 1]);
      return function(t3, r2) {
        let n2 = 0, a2 = 0, o2 = 0;
        const h2 = (t3 + r2) * st, l2 = nt(t3 + h2), c2 = nt(r2 + h2), u2 = (l2 + c2) * rt, g2 = t3 - (l2 - u2), d2 = r2 - (c2 - u2);
        let m2, p2;
        g2 > d2 ? (m2 = 1, p2 = 0) : (m2 = 0, p2 = 1);
        const x2 = g2 - m2 + rt, f2 = d2 - p2 + rt, v2 = g2 - 1 + 2 * rt, A2 = d2 - 1 + 2 * rt, M2 = 255 & l2, w2 = 255 & c2;
        let y2 = 0.5 - g2 * g2 - d2 * d2;
        if (y2 >= 0) {
          const t4 = M2 + e2[w2];
          y2 *= y2, n2 = y2 * y2 * (i2[t4] * g2 + s2[t4] * d2);
        }
        let E2 = 0.5 - x2 * x2 - f2 * f2;
        if (E2 >= 0) {
          const t4 = M2 + m2 + e2[w2 + p2];
          E2 *= E2, a2 = E2 * E2 * (i2[t4] * x2 + s2[t4] * f2);
        }
        let U2 = 0.5 - v2 * v2 - A2 * A2;
        if (U2 >= 0) {
          const t4 = M2 + 1 + e2[w2 + 1];
          U2 *= U2, o2 = U2 * U2 * (i2[t4] * v2 + s2[t4] * A2);
        }
        return 70 * (n2 + a2 + o2);
      };
    }(Math.random);
    function ct(t2) {
      return Math.max(0, Math.min(1, t2));
    }
    const ut = "float PI = 3.141592653589793238;", gt = "\nprecision highp float;\n\nuniform float time;\nuniform float progress;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform vec4 resolution;\nvarying vec2 vUv;\n", dt = "\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute float offset;\nattribute vec3 bary;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float progress;\nuniform vec4 resolution;\n\nvarying vec2 vUv;\nvarying float vProgress;\nvarying float vProgress1;\nvarying vec3 vBary;\n", mt = "\nmat4 rotationMatrix(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n              oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n              oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n              0.0,                                0.0,                                0.0,                                1.0);\n}\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n  mat4 m = rotationMatrix(axis, angle);\n  return (m * vec4(v, 1.0)).xyz;\n}\n", pt = { dots: { uniforms: {}, fragment: `
    ${gt}
    const float SQRT_2 = 1.414213562373;
    const vec2 center = vec2(0, 0);// = vec2(0, 0);
    const float dots = 20.0;// = 20.0;

    vec4 getFromColor(vec2 p) {
      return texture2D(texture1, p);
    }

    vec4 getToColor(vec2 p) {
      return texture2D(texture2, p);
    }

    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      bool nextImage = distance(fract(newUV * dots), vec2(0.5, 0.5)) < ( progress / distance(newUV, center));
      gl_FragColor = nextImage ? getToColor(newUV) : getFromColor(newUV);
    }

  ` }, "dots-circle": { uniforms: {}, fragment: `
    ${gt}
    const float SQRT_2 = 1.414213562373;
    // Center should be 0.5, 0.5 for UV space
    const vec2 center = vec2(0.5, 0.5);
    const float dots = 20.0;// = 20.0;

    vec4 getFromColor(vec2 p) {
      return texture2D(texture1, p);
    }

    vec4 getToColor(vec2 p) {
      return texture2D(texture2, p);
    }

    void main()	{
      float aspect = resolution.x / resolution.y;
      // Screen-corrected UVs for dot pattern calculation (makes dots appear square on screen)
      vec2 screenUV = (vUv - center) * vec2(aspect, 1.0) + center;

      // Aspect-corrected UVs for texture sampling (using resolution uniform)
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      // Calculate overall distance threshold using original vUv for a circular boundary
      float dist = distance(vUv, center); // center is (0.5, 0.5)

      // Calculate dot pattern distance using screen-corrected UVs for screen-square dots
      float dotPatternDist = distance(fract(screenUV * dots), vec2(0.5, 0.5));

      // Compare dot pattern distance (screen-square dots) with circular threshold boundary
      bool nextImage = dotPatternDist < ( progress / dist );

      // Sample textures using aspect-corrected newUV
      gl_FragColor = nextImage ? getToColor(newUV) : getFromColor(newUV);
    }

  ` }, flyeye: { uniforms: {}, fragment: `
    ${gt}
    const float size = 0.04; // = 0.04
    const float zoom = 100.0; // = 50.0
    const float colorSeparation = 0.3; // = 0.3

    vec4 getFromColor(vec2 p) {
      return texture2D(texture1, p);
    }

    vec4 getToColor(vec2 p) {
      return texture2D(texture2, p);
    }

    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      float inv = 1. - progress;
      vec2 disp = size*vec2(cos(zoom*newUV.x), sin(zoom*newUV.y));
      vec4 texTo = getToColor(newUV + inv*disp);
      vec4 texFrom = vec4(
        getFromColor(newUV + progress*disp*(1.0 - colorSeparation)).r,
        getFromColor(newUV + progress*disp).g,
        getFromColor(newUV + progress*disp*(1.0 + colorSeparation)).b,
        1.0);
      gl_FragColor = texTo*progress + texFrom*inv;
    }

  ` }, "morph-x": { uniforms: { intensity: { value: 1, type: "f", min: 0, max: 3 } }, fragment: `
  ${gt}
  uniform float intensity;
  uniform sampler2D displacement;
  mat2 getRotM(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat2(c, -s, s, c);
  }
  const float PI = 3.1415;
  const float angle1 = PI *0.25;
  const float angle2 = -PI *0.75;
  void main()	{
    vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
    vec4 disp = texture2D(displacement, newUV);
    vec2 dispVec = vec2(disp.r, disp.g);
    vec2 distortedPosition1 = newUV + getRotM(angle1) * dispVec * intensity * progress;
    vec4 t1 = texture2D(texture1, distortedPosition1);
    vec2 distortedPosition2 = newUV + getRotM(angle2) * dispVec * intensity * (1.0 - progress);
    vec4 t2 = texture2D(texture2, distortedPosition2);
    gl_FragColor = mix(t1, t2, progress);
  }
` }, "morph-y": { uniforms: { intensity: { value: 0.3, type: "f", min: 0, max: 2 } }, fragment: `
  ${gt}
  uniform float intensity;
  uniform sampler2D displacement;
  void main()	{
    vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
    vec4 d1 = texture2D(texture1, newUV);
    vec4 d2 = texture2D(texture2, newUV);
    float displace1 = (d1.r + d1.g + d1.b)*0.33;
    float displace2 = (d2.r + d2.g + d2.b)*0.33;

    vec4 t1 = texture2D(texture1, vec2(newUV.x, newUV.y + progress * (displace2 * intensity)));
    vec4 t2 = texture2D(texture2, vec2(newUV.x, newUV.y + (1.0 - progress) * (displace1 * intensity)));
    gl_FragColor = mix(t1, t2, progress);
  }
` }, "page-curl": { uniforms: {}, fragment: `
    ${gt}
    const float MIN_AMOUNT = -0.16;
    const float MAX_AMOUNT = 1.5;

    const float PI = 3.141592653589793;

    const float scale = 512.0;
    const float sharpness = 3.0;

    const float cylinderRadius = 1.0 / PI / 2.0;

    vec4 getFromColor(vec2 p) {
      return texture2D(texture1, p);
    }

    vec4 getToColor(vec2 p) {
      return texture2D(texture2, p);
    }

    vec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation) {
      float hitPoint = hitAngle / (2.0 * PI);
      point.y = hitPoint;
      return rrotation * point;
    }

    vec4 antiAlias(vec4 color1, vec4 color2, float distanc) {
      distanc *= scale;
      if(distanc < 0.0)
        return color2;
      if(distanc > 2.0)
        return color1;
      float dd = pow(1.0 - distanc / 2.0, sharpness);
      return ((color2 - color1) * dd) + color1;
    }

    float distanceToEdge(vec3 point) {
      float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);
      float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);
      if(point.x < 0.0)
        dx = -point.x;
      if(point.x > 1.0)
        dx = point.x - 1.0;
      if(point.y < 0.0)
        dy = -point.y;
      if(point.y > 1.0)
        dy = point.y - 1.0;
      if((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0))
        return sqrt(dx * dx + dy * dy);
      return min(dx, dy);
    }

    vec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation, float cylinderAngle) {
      float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);
      vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);
      if(yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)) {
        return getToColor(p);
      }

      if(yc > 0.0)
        return getFromColor(p);

      vec4 color = getFromColor(point.xy);
      vec4 tcolor = vec4(0.0);

      return antiAlias(color, tcolor, distanceToEdge(point));
    }

    vec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation, float cylinderAngle, float amount) {
      float shadow = distanceToEdge(point) * 30.0;
      shadow = (1.0 - shadow) / 3.0;

      if(shadow < 0.0)
        shadow = 0.0;
      else
        shadow *= amount;

      vec4 shadowColor = seeThrough(yc, p, rotation, rrotation, cylinderAngle);
      shadowColor.r -= shadow;
      shadowColor.g -= shadow;
      shadowColor.b -= shadow;

      return shadowColor;
    }

    vec4 backside(float yc, vec3 point) {
      vec4 color = getFromColor(point.xy);
      float gray = (color.r + color.b + color.g) / 15.0;
      gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));
      color.rgb = vec3(gray);
      return color;
    }

    vec4 behindSurface(vec2 p, float yc, vec3 point, mat3 rrotation, float cylinderAngle, float amount) {
      float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;
      shado *= 1.0 - abs(point.x - 0.5);

      yc = (-cylinderRadius - cylinderRadius - yc);

      float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;
      point = hitPoint(hitAngle, yc, point, rrotation);

      if(yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5)) {
        shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));
        shado *= pow(-yc / cylinderRadius, 3.0);
        shado *= 0.5;
      } else {
        shado = 0.0;
      }
      return vec4(getToColor(p).rgb - shado, 1.0);
    }

    void main() {
      vec2 newUV = (vUv - vec2(0.5)) * resolution.zw + vec2(0.5);

      float amount = progress * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;
      float cylinderCenter = amount;
          // 360 degrees * amount
      float cylinderAngle = 2.0 * PI * amount;

      const float angle = 100.0 * PI / 180.0;
      float c = cos(-angle);
      float s = sin(-angle);

      mat3 rotation = mat3(c, s, 0, -s, c, 0, -0.801, 0.8900, 1);
      c = cos(angle);
      s = sin(angle);

      mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.98500, 0.985, 1);

      vec3 point = rotation * vec3(newUV, 1.0);

      float yc = point.y - cylinderCenter;

      if(yc < -cylinderRadius) {
                        // Behind surface
        gl_FragColor = behindSurface(newUV, yc, point, rrotation, cylinderAngle, amount);
        return;
      }

      if(yc > cylinderRadius) {
                        // Flat surface
        gl_FragColor = getFromColor(newUV);
        return;
      }

      float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;

      float hitAngleMod = mod(hitAngle, 2.0 * PI);
      if((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI / 2.0 && amount < 0.0)) {
        gl_FragColor = seeThrough(yc, newUV, rotation, rrotation, cylinderAngle);
        return;
      }

      point = hitPoint(hitAngle, yc, point, rrotation);

      if(point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) {
        gl_FragColor = seeThroughWithShadow(yc, newUV, point, rotation, rrotation, cylinderAngle, amount);
        return;
      }

      vec4 color = backside(yc, point);

      vec4 otherColor;
      if(yc < 0.0) {
        float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);
        shado *= pow(-yc / cylinderRadius, 3.0);
        shado *= 0.5;
        otherColor = vec4(0.0, 0.0, 0.0, shado);
      } else {
        otherColor = getFromColor(newUV);
      }

      color = antiAlias(color, otherColor, cylinderRadius - abs(yc));

      vec4 cl = seeThroughWithShadow(yc, newUV, point, rotation, rrotation, cylinderAngle, amount);
      float dist = distanceToEdge(point);

      gl_FragColor = antiAlias(color, cl, dist);
    }
  ` }, "peel-x": { uniforms: {}, fragment: `
    ${gt}
    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
      vec2 p = newUV;
      float x = progress;
      x = smoothstep(.0,1.0,(x*2.0+p.x-1.0));
      vec4 f = mix(
        texture2D(texture1, (p-.5)*(1.-x)+.5),
        texture2D(texture2, (p-.5)*x+.5),
        x);
      gl_FragColor = f;
    }
  ` }, "peel-y": { uniforms: {}, fragment: `
    ${gt}
    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
      vec2 p = newUV;
      float x = progress;
      x = smoothstep(.0,1.0,(x*2.0+p.y-1.0));
      vec4 f = mix(
        texture2D(texture1, (p-.5)*(1.-x)+.5),
        texture2D(texture2, (p-.5)*x+.5),
        x);
      gl_FragColor = f;
    }
  ` }, "polygons-fall": { uniforms: {}, detail: 12, offsetTop: 0, vertex: `
    ${dt}
    attribute vec3 centroid1;

    ${mt}

    void main() {
      ${ut}
      vUv = uv;
      vBary = bary;

      vec3 newpos = position;

      float o = 1. - offset;
      float pr = (progress - 0.5) * (0. + resolution.y / resolution.x) + 0.5;
      pr = progress;
      float prog = clamp((pr - o * 0.9) / 0.1, 0., 1.);
      vProgress = prog;
      vProgress1 = clamp((pr - clamp(o - 0.1, 0., 1.) * 0.9) / 0.1, 0., 1.);
      newpos = rotate((newpos - centroid1), vec3(1., 0., 0.), -prog * PI) + centroid1 + vec3(0., -1., 0.) * prog * 0.;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newpos, 1.0);
    }
  `, fragment: `
    ${gt}
    varying float vProgress;
    varying float vProgress1;
    ${ut}
    varying vec3 vBary;

    void main()	{
      float width = 2.5 * vProgress1;
      vec3 d;
      #ifdef GL_OES_standard_derivatives
        d = fwidth(vBary);
      #endif
      vec3 s = smoothstep(d * (width + 0.5), d * (width - 0.5), vBary);
      float alpha = max(max(s.x, s.y), s.z);
      vec3 color = vec3(alpha);
      vec2 newUV = (vUv - vec2(0.5)) * resolution.zw + vec2(0.5);
      vec4 t = texture2D(texture1, newUV);
      float opa = smoothstep(1., 0.5, vProgress);
      opa = 1. - vProgress;
      gl_FragColor = vec4(vUv, 0.0, opa);
      gl_FragColor = vec4(t.rgb + .5 * color * vProgress1, opa);
    }
  ` }, "polygons-morph": { uniforms: {}, detail: 20, offsetTop: 0.4, vertex: `
    ${dt}
    ${mt}

    void main() {
      ${ut}
      vUv = uv;
      vBary = bary;

      vec3 newpos = position;

      float o = 1. - offset;
      float prog = clamp((progress - o * 0.6) / 0.4, 0., 1.);
      vProgress = prog;
      vProgress1 = clamp((progress - clamp(o - 0.1, -0., 1.) * 0.9) / 0.1, 0., 1.);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newpos, 1.0);
    }
  `, fragment: `
    ${gt}
    varying float vProgress;
    varying float vProgress1;
    ${ut}
    varying vec3 vBary;
    void main()	{
      float width = 2.5 * vProgress1;
      vec3 d;
      #ifdef GL_OES_standard_derivatives
        d = fwidth(vBary);
      #endif
      vec3 s = smoothstep(d * (width + 0.5), d * (width - 0.5), vBary);
      float alpha = max(max(s.x, s.y), s.z);
      vec3 color = vec3(alpha);

      vec2 newUV = (vUv - vec2(0.5)) * resolution.zw + vec2(0.5);
      vec4 t = texture2D(texture1, newUV);
      float opa = smoothstep(1., 0.5, vProgress);
      opa = 1. - vProgress;
      gl_FragColor = vec4(t.rgb + 1. * color * vProgress1, opa);
    }
  ` }, "polygons-wind": { uniforms: {}, detail: 40, offsetTop: 1, vertex: `
    ${dt}
    attribute vec3 control0;
    attribute vec3 control1;

    ${mt}

    float easeOut(float t){
      return  t * t * t;
    }

    vec3 bezier4(vec3 a, vec3 b, vec3 c, vec3 d, float t) {
      return mix(mix(mix(a, b, t), mix(b, c, t), t), mix(mix(b, c, t), mix(c, d, t), t), t);
    }

    void main() {
      ${ut}
      vUv = uv;
      vBary = bary;

      vec3 newpos = position;

      float o = 1. - offset;
      float prog = clamp((progress - o * 0.6) / 0.4, 0., 1.);
      vProgress = prog;
      vProgress1 = clamp((progress - clamp(o - 0.2, -0., 1.) * 0.6) / 0.4, 0., 1.);
      newpos = bezier4(newpos, control0, control1, newpos, easeOut(prog));
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newpos, 1.0);
    }
  `, fragment: `
    ${gt}
    varying float vProgress;
    varying float vProgress1;
    ${ut}
    varying vec3 vBary;
    void main()	{
      float width = 2.5 * vProgress1;
      vec3 d;
      #ifdef GL_OES_standard_derivatives
        d = fwidth(vBary);
      #endif
      vec3 s = smoothstep(d * (width + 0.5), d * (width - 0.5), vBary);
      float alpha = max(max(s.x, s.y), s.z);
      vec3 color = vec3(alpha);

      vec2 newUV = (vUv - vec2(0.5)) * resolution.zw + vec2(0.5);
      vec4 t = texture2D(texture1, newUV);
      float opa = smoothstep(1., 0.5, vProgress);
      opa = 1. - vProgress;
      gl_FragColor = vec4(vUv, 0.0, opa);
      opa = smoothstep(0.5, 1., opa);
      gl_FragColor = vec4(t.rgb + 1. * color * vProgress1, opa);
    }
  ` }, pixelize: { uniforms: {}, fragment: `
    ${gt}
    ivec2 squaresMin = ivec2(50);
    int steps = 20;

    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      float d = min(progress, 1.0 - progress);
      float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;
      vec2 squareSize = 2.0 * dist / vec2(squaresMin);

      vec2 p = dist>0.0 ? (floor(newUV / squareSize) + 0.5) * squareSize : newUV;

      vec2 uv1 = newUV;
      vec2 uv2 = newUV;

      vec4 t1 = texture2D(texture1,p);
      vec4 t2 = texture2D(texture2,p);

      gl_FragColor = mix(t1, t2, progress);
    }
  ` }, ripple: { uniforms: { radius: { value: 0.9, type: "f", min: 0.1, max: 2 }, width: { value: 0.35, type: "f", min: 0, max: 1 } }, fragment: `
    ${gt}
    uniform float width;
    uniform float radius;
    uniform sampler2D displacement;
    float parabola( float x, float k ) {
      return pow( 4. * x * ( 1. - x ), k );
    }
    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
      vec2 p = newUV;
      vec2 start = vec2(0.5,0.5);
      vec2 aspect = resolution.wz;
      vec2 uv = newUV;
      float dt = parabola(progress, 1.);
      vec4 noise = texture2D(displacement, fract(vUv+time*0.04));
      float prog = progress*0.66 + noise.g * 0.04;
      float circ = 1. - smoothstep(-width, 0.0, radius * distance(start*aspect, uv*aspect) - prog*(1.+width));
      float intpl = pow(abs(circ), 1.);
      vec4 t1 = texture2D( texture1, (uv - 0.5) * (1.0 - intpl) + 0.5 ) ;
      vec4 t2 = texture2D( texture2, (uv - 0.5) * intpl + 0.5 );
      gl_FragColor = mix( t1, t2, intpl );
    }
  ` }, shutters: { uniforms: { intensity: { value: 50, type: "f", min: 1, max: 100 } }, fragment: `
    ${gt}
    uniform float intensity;
    mat2 rotate(float a) {
      float s = sin(a);
      float c = cos(a);
      return mat2(c, -s, s, c);
    }
    const float PI = 3.1415;
    const float angle1 = PI *0.25;
    const float angle2 = PI *0.25;

    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      vec2 uvDivided = fract(newUV*vec2(intensity,1.));

      vec2 uvDisplaced1 = newUV + rotate(angle1)*uvDivided*progress*0.1;
      vec2 uvDisplaced2 = newUV + rotate(angle2)*uvDivided*(1. - progress)*0.1;

      vec4 t1 = texture2D(texture1,uvDisplaced1);
      vec4 t2 = texture2D(texture2,uvDisplaced2);

      gl_FragColor = mix(t1, t2, progress);
    }

  ` }, slices: { uniforms: { size: { value: 0.25, type: "f", min: 0.1, max: 1 } }, fragment: `
    ${gt}
    uniform float size; // = 0.2
    float count = 20.; // = 10.0
    float smoothness = .5; // = 0.5
    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      float pr = smoothstep(-smoothness, 0.0, newUV.x - progress * (1.0 + smoothness));
      float s = step(pr, fract(count * newUV.x));

      vec2 uv1 = newUV;
      vec2 uv2 = newUV;

      vec4 t1 = texture2D(texture1,uv1);
      vec4 t2 = texture2D(texture2,uv2);
      gl_FragColor = mix(t1, t2, s);

    }
  ` }, squares: { uniforms: {}, fragment: `
    ${gt}
    ivec2 squares = ivec2(10,10);
    vec2 direction = vec2(1.0, -0.5);
    float smoothness = 1.6;

    const vec2 center = vec2(0.5, 0.5);
    void main() {
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      vec2 v = normalize(direction);
      v /= abs(v.x)+abs(v.y);
      float d = v.x * center.x + v.y * center.y;
      float offset = smoothness;
      float pr = smoothstep(-offset, 0.0, v.x * newUV.x + v.y * newUV.y - (d-0.5+progress*(1.+offset)));
      vec2 squarep = fract(newUV*vec2(squares));
      vec2 squaremin = vec2(pr/2.0);
      vec2 squaremax = vec2(1.0 - pr/2.0);
      float a = (1.0 - step(progress, 0.0)) * step(squaremin.x, squarep.x) * step(squaremin.y, squarep.y) * step(squarep.x, squaremax.x) * step(squarep.y, squaremax.y);

      vec2 uv1 = newUV;
      vec2 uv2 = newUV;

      vec4 t1 = texture2D(texture1,newUV);
      vec4 t2 = texture2D(texture2,newUV);

      gl_FragColor = mix(t1, t2, a);
    }
  ` }, stretch: { uniforms: { intensity: { value: 50, type: "f", min: 1, max: 100 } }, fragment: `
    ${gt}
    uniform float intensity;
    mat2 rotate(float a) {
      float s = sin(a);
      float c = cos(a);
      return mat2(c, -s, s, c);
    }
    const float PI = 3.1415;
    const float angle1 = PI *0.25;
    const float angle2 = -PI *0.75;
    const float noiseSeed = 2.;
    float random() {
      return fract(sin(noiseSeed + dot(gl_FragCoord.xy / resolution.xy / 10.0, vec2(12.9898, 4.1414))) * 43758.5453);
    }
    float hash(float n) { return fract(sin(n) * 1e4); }
    float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
    float hnoise(vec2 x) {
      vec2 i = floor(x);
      vec2 f = fract(x);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }
    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      float hn = hnoise(newUV.xy * resolution.xy / 100.0);
      vec2 d = vec2(0.,normalize(vec2(0.5,0.5) - newUV.xy).y);
      vec2 uv1 = newUV + d * progress / 5.0 * (1.0 + hn / 2.0);
      vec2 uv2 = newUV - d * (1.0 - progress) / 5.0 * (1.0 + hn / 2.0);
      vec4 t1 = texture2D(texture1,uv1);
      vec4 t2 = texture2D(texture2,uv2);
      gl_FragColor = mix(t1, t2, progress);
    }
  ` }, "wave-x": { uniforms: {}, fragment: `
  ${gt}
  uniform sampler2D displacement;
  vec2 mirrored(vec2 v) {
    vec2 m = mod(v,2.);
    return mix(m,2.0 - m, step(1.0 ,m));
  }
  void main()	{
    vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);
    vec4 noise = texture2D(displacement, mirrored(newUV+time*0.04));
    float prog = (1.0 - progress)*0.8 -0.05 + noise.g * 0.06;
    float intpl = pow(abs(smoothstep(0., 1., (prog*2. - vUv.x + 0.5))), 10.);

    vec4 t1 = texture2D( texture2, (newUV - 0.5) * (1.0 - intpl) + 0.5 ) ;
    vec4 t2 = texture2D( texture1, (newUV - 0.5) * intpl + 0.5 );
    gl_FragColor = mix( t1, t2, intpl );
  }
  ` }, wind: { uniforms: {}, fragment: `
    ${gt}
    float size = 0.2;

    float rand (vec2 co) {
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    void main()	{
      vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);

      float r = rand(vec2(0, newUV.y));
      float m = smoothstep(0.0, -size, newUV.x*(1.0-size) + size*r - ((progress) * (1.0 + size)));

      vec2 uv1 = newUV;
      vec2 uv2 = newUV;

      vec4 t1 = texture2D(texture1,uv1);
      vec4 t2 = texture2D(texture2,uv2);
      gl_FragColor = mix(t1, t2, m);

    }
  ` } }, xt = "\nattribute vec2 uv;\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n", ft = (t2, e2) => {
      const { shaderPerSlide: i2, swiper: s2 } = e2, r2 = s2.params.loop ? s2.realIndex : s2.activeIndex;
      let n2 = pt;
      if (Array.isArray(t2) && t2.length) {
        if (i2)
          return void 0 === t2[r2] ? pt[t2[0]] : pt[t2[r2]];
        n2 = {}, Object.keys(pt).forEach((e3) => {
          t2.includes(e3) && (n2[e3] = pt[e3]);
        });
      }
      const a2 = Math.floor(Math.random() * Object.keys(n2).length);
      return n2[Object.keys(n2)[a2]];
    };
    class vt {
      constructor(t2) {
        const e2 = "random" === t2.shader || Array.isArray(t2.shader) ? ft(t2.shader, t2) : pt[t2.shader];
        this.shader = e2, this.displacement = t2.displacementMap || "data:image/jpeg;base64,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", this.scene = new O(), this.swiper = t2.swiper, this.vertex = e2.vertex || xt, this.fragment = e2.fragment, this.uniforms = e2.uniforms || {}, this.renderer = new F({ dpr: 2, webgl: 2, alpha: true }), this.gl = this.renderer.gl, this.width = window.innerWidth, this.height = window.innerHeight, this.renderer.setSize(this.width, this.height), this.gl.clearColor(1, 1, 1, 0), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.opts = t2, this.container = this.swiper.el, this.displacementTexture = null, this.width = this.swiper.width, this.height = this.swiper.height, this.swiper.isElement && (this.gl.canvas.setAttribute("slot", "container-start"), this.swiper.hostEl.classList.add("swiper-gl")), this.container.prepend(this.gl.canvas), this.camera = new J(this.gl, { fov: 45 }), this.camera.perspective({ aspect: this.gl.canvas.width / this.gl.canvas.height }), this.camera.position.set(0, 0, 2), this.time = 0, this.current = 0, this.init(() => {
          this.addObjects(), this.resize(), this.render();
        });
      }
      animateUniform(t2, e2, i2) {
        const s2 = t2.value;
        let r2, n2 = null;
        window.cancelAnimationFrame(this.animateUniformFrame);
        const a2 = e2 > t2.value ? "next" : "prev", o2 = (t3, e3) => "next" === a2 && t3 >= e3 || "prev" === a2 && t3 <= e3, h2 = () => {
          if (this.destroyed)
            return;
          r2 = (/* @__PURE__ */ new Date()).getTime(), null === n2 && (n2 = r2);
          const a3 = Math.max(Math.min((r2 - n2) / this.swiper.params.speed, 1), 0), l2 = 0.5 - Math.cos(a3 * Math.PI) / 2;
          let c2 = s2 + l2 * (e2 - s2);
          if (o2(c2, e2) && (c2 = e2), t2.value = c2, o2(c2, e2))
            return cancelAnimationFrame(this.animateUniformFrame), void (i2 && i2());
          this.animateUniformFrame = requestAnimationFrame(h2);
        };
        h2();
      }
      loadTextures() {
        const t2 = [], e2 = this;
        this.images = [], this.textures = [];
        return (this.swiper && this.swiper.isElement ? this.swiper.hostEl : this.container).querySelectorAll(".swiper-gl-image").forEach((t3) => {
          this.images.push(t3.src);
        }), this.images.forEach((i2, s2) => {
          const r2 = new Promise((t3) => {
            const r3 = new Image();
            r3.crossOrigin = "anonymous";
            const n2 = new tt(this.gl);
            r3.onload = () => {
              n2.image = r3, e2.textures[s2] = n2, t3();
            }, r3.src = i2;
          });
          t2.push(r2);
        }), t2.push(new Promise((t3) => {
          const i2 = new Image();
          i2.crossOrigin = "anonymous";
          const s2 = new tt(this.gl);
          i2.onload = () => {
            s2.image = i2, e2.displacementTexture = s2, t3();
          }, i2.src = this.displacement;
        })), Promise.all(t2);
      }
      init(t2) {
        this.loadTextures().then(() => {
          this.initialized = true, this.onInit && this.onInit(), t2();
        });
      }
      resize() {
        if (!this.initialized || this.destroyed)
          return;
        const { width: t2, height: e2 } = this.swiper;
        this.width = t2, this.height = e2, this.renderer.setSize(t2, e2);
        const i2 = this.camera.position.z;
        if (this.camera.perspective({ aspect: t2 / e2, fov: 180 / Math.PI * 2 * Math.atan(1 / (2 * i2)) }), !this.textures[0].image)
          return;
        const s2 = this.textures[0].image.height / this.textures[0].image.width;
        let r2, n2;
        e2 / t2 > s2 ? (r2 = t2 / e2 * s2, n2 = 1) : (r2 = 1, n2 = e2 / t2 / s2), this.material.uniforms.resolution.value.x = t2, this.material.uniforms.resolution.value.y = e2, this.material.uniforms.resolution.value.z = r2, this.material.uniforms.resolution.value.w = n2, this.shader.vertex && this.vertexMaterial && (this.vertexMaterial.uniforms.resolution.value.x = t2, this.vertexMaterial.uniforms.resolution.value.y = e2, this.vertexMaterial.uniforms.resolution.value.z = r2, this.vertexMaterial.uniforms.resolution.value.w = n2), this.shader.vertex ? (this.nextMesh.scale.set(this.camera.aspect / 2, 0.5, 0.5), this.currentMesh.scale.set(this.camera.aspect / 2, 0.5, 0.5)) : (this.plane.scale.x = this.camera.aspect, this.plane.scale.y = 1);
      }
      createMaterial() {
        return new v(this.gl, { extensions: { derivatives: "#extension GL_OES_standard_derivatives : enable" }, uniforms: { time: { type: "f", value: 0 }, progress: { type: "f", value: 0 }, intensity: { type: "f", value: 0 }, width: { type: "f", value: 0 }, radius: { type: "f", value: 0 }, size: { type: "f", value: 0 }, texture1: { type: "f", value: this.textures[0] }, texture2: { type: "f", value: this.textures[1] }, displacement: { type: "f", value: this.displacementTexture }, resolution: { type: "v4", value: new et() } }, vertex: this.shader.vertex || xt, fragment: this.shader.fragment, ...this.shader.vertex ? { transparent: true, depthWrite: false } : {} });
      }
      addObjects() {
        if (this.scene.children.forEach((t2) => {
          this.scene.removeChild(t2);
        }), this.scene.children.forEach((t2) => {
          this.scene.removeChild(t2);
        }), this.material = this.createMaterial(), this.shader.vertex) {
          const t2 = function(t3, e3, i2) {
            i2 = i2 || 0;
            const s2 = e3, r2 = 2 / s2, n2 = r2 * Math.sqrt(3) / 2, a2 = 2 / n2, o2 = [], h2 = [], l2 = [], c2 = [], u2 = [], g2 = [], d2 = [];
            let m2 = 0;
            const x2 = [];
            let f2 = 0;
            for (let t4 = 0; t4 < a2; t4 += 1) {
              f2 = t4 * n2, m2 = t4 % 2 == 1 ? -r2 / 2 : 0;
              for (let p2 = 0; p2 <= s2; p2 += 1) {
                const s3 = Math.sign(p2 * r2 + m2 - 1);
                h2.push(p2 * r2 + m2 - 1, f2 - 1, 0), d2.push((p2 * r2 + m2) / 2, f2 / 2), h2.push(p2 * r2 + r2 / 2 + m2 - 1, n2 + f2 - 1, 0), d2.push((p2 * r2 + r2 / 2 + m2) / 2, (n2 + f2) / 2), h2.push(p2 * r2 - r2 / 2 + m2 - 1, n2 + f2 - 1, 0), d2.push((p2 * r2 - r2 / 2 + m2) / 2, (n2 + f2) / 2);
                let v3 = lt(p2 / a2, t4 / a2) + Math.random();
                const A2 = ct(f2 / 2 + 2 * v3 / e3);
                let M2 = Math.random();
                o2.push(A2, ct(A2 + 0.1 * i2), ct(A2 + 0.1 * i2)), g2.push(M2, M2, M2);
                const w2 = [p2 * r2 + m2 - 1, f2 - 1, 0];
                l2.push(...w2, ...w2, ...w2);
                const y2 = [2 * s3 * ht(-0.3, 0.3), -2 * ht(-0.3, 0.3) * 1.5, -ot(0.5)], E2 = [2 * s3 * ht(0.3, 0.6), -2 * ht(0.3, 0.6) * 1.5, -ot(0.5)];
                c2.push(...y2, ...y2, ...y2), u2.push(...E2, ...E2, ...E2), x2.push(0, 0, 1, 0, 1, 0, 1, 0, 0), h2.push(p2 * r2 + m2 - 1, f2 - 1, 0), d2.push((p2 * r2 + m2) / 2, f2 / 2), h2.push(p2 * r2 + r2 + m2 - 1, f2 - 1, 0), d2.push((p2 * r2 + r2 + m2) / 2, f2 / 2), h2.push(p2 * r2 + r2 / 2 + m2 - 1, n2 + f2 - 1, 0), d2.push((p2 * r2 + r2 / 2 + m2) / 2, (n2 + f2) / 2), v3 = lt((p2 + 1) / a2, t4 / a2) + Math.random();
                const U2 = ct(f2 / 2 + 2 * v3 / e3);
                M2 = Math.random(), o2.push(U2, U2, ct(U2 + 0.1 * i2)), g2.push(M2, M2, M2);
                const F2 = [p2 * r2 + m2 - 1, f2 - 1, 0];
                c2.push(...y2, ...y2, ...y2), u2.push(...E2, ...E2, ...E2), l2.push(...F2, ...F2, ...F2), x2.push(0, 0, 1, 0, 1, 0, 1, 0, 0);
              }
            }
            const v2 = new p(t3);
            return v2.addAttribute("position", { size: 3, data: new Float32Array(h2) }), v2.addAttribute("bary", { size: 3, data: new Float32Array(x2) }), v2.addAttribute("uv", { size: 2, data: new Float32Array(d2) }), v2.addAttribute("offset", { size: 1, data: new Float32Array(o2) }), v2.addAttribute("centroid1", { size: 3, data: new Float32Array(l2) }), v2.addAttribute("control0", { size: 3, data: new Float32Array(c2) }), v2.addAttribute("control1", { size: 3, data: new Float32Array(u2) }), v2.addAttribute("random", { size: 1, data: new Float32Array(g2) }), v2;
          }(this.gl, this.shader.detail, this.shader.offsetTop), e2 = this.textures[1];
          this.vertexMaterial = this.createMaterial(), this.vertexMaterial.uniforms.texture1.value = e2, this.currentMesh = new q(this.gl, { geometry: t2, program: this.material }), this.nextMesh = new q(this.gl, { geometry: t2, program: this.vertexMaterial }), this.nextMesh.position.z = -1e-4, this.currentMesh.setParent(this.scene), this.nextMesh.setParent(this.scene);
        } else {
          const t2 = new it(this.gl, { width: 1, height: 1, widthSegments: 2, heightSegments: 2 });
          this.plane = new q(this.gl, { geometry: t2, program: this.material }), this.plane.setParent(this.scene);
        }
      }
      replaceShader(t2) {
        let e2, i2;
        this.shader.vertex ? (e2 = this.material.uniforms.texture1.value, i2 = this.vertexMaterial.uniforms.texture1.value) : (e2 = this.material.uniforms.texture1.value, i2 = this.material.uniforms.texture2.value);
        const s2 = "random" === t2 || Array.isArray(t2) ? ft(t2, this.opts) : pt[t2], { fragment: r2, uniforms: n2, vertex: a2 } = s2;
        this.shader = s2, this.vertex = a2 || xt, this.fragment = r2 || "", this.uniforms = n2 || {}, this.addObjects(), this.shader.vertex ? (this.material.uniforms.texture1.value = i2, this.vertexMaterial.uniforms.texture1.value = i2) : (this.material.uniforms.texture1.value = e2, this.material.uniforms.texture2.value = i2, this.material.uniforms.progress.value = 1), this.resize(), this.swiper.params.gl.shader = t2;
      }
      replaceRandomShader() {
        const t2 = ft(this.opts.shader, this.opts), { fragment: e2, uniforms: i2, vertex: s2 } = t2;
        this.shader = t2, this.fragment = e2 || "", this.uniforms = i2 || {}, this.vertex = s2 || xt, this.addObjects(), this.resize();
      }
      setProgress(t2, e2, i2, s2, r2) {
        if (this.destroyed || this.swiper.glDestroyed)
          return;
        if (!this.initialized)
          return void (this.onInit = () => {
            requestAnimationFrame(() => {
              this.setProgress(t2, e2, i2, s2);
            });
          });
        this.swiper.params.loop && this.swiper.slides[t2] && this.swiper.slides[e2] && (t2 = parseInt(this.swiper.slides[t2].getAttribute("data-swiper-slide-index"), 10), e2 = parseInt(this.swiper.slides[e2].getAttribute("data-swiper-slide-index"), 10));
        const n2 = this.textures[e2], a2 = this.textures[t2];
        if (this.material.uniforms.texture1.value = a2, this.shader.vertex ? this.vertexMaterial.uniforms.texture1.value = n2 : this.material.uniforms.texture2.value = n2, r2) {
          if (this.preventShaderReplace)
            return void (this.material.uniforms.progress.value = Math.abs(i2));
          this.preventShaderReplace = true, requestAnimationFrame(() => {
            this.preventShaderReplace = false;
          }), "random" === this.swiper.params.gl.shader || Array.isArray(this.swiper.params.gl.shader) ? (this.replaceRandomShader(), this.material.uniforms.texture1.value = a2, this.material.uniforms.texture2.value = n2, this.material.uniforms.progress.value = Math.abs(i2)) : this.material.uniforms.progress.value = Math.abs(i2);
        } else
          s2 ? (0 === i2 && 0 === this.material.uniforms.progress.value && (this.material.uniforms.progress.value = 1), 1 === i2 && 1 === this.material.uniforms.progress.value && (this.material.uniforms.progress.value = 0), this.animateUniform(this.material.uniforms.progress, i2, () => {
            ("random" === this.swiper.params.gl.shader || Array.isArray(this.swiper.params.gl.shader)) && (this.replaceRandomShader(), this.material.uniforms.texture1.value = a2, this.material.uniforms.texture2.value = n2, this.material.uniforms.progress.value = i2), 1 === i2 && (this.material.uniforms.texture1.value = n2), this.material.uniforms.progress.value = 0;
          })) : this.material.uniforms.progress.value = Math.abs(i2);
      }
      render() {
        this.swiper.destroyed || this.destroyed || (this.time += 0.05, this.material.uniforms.time.value = this.time, Object.keys(this.uniforms).forEach((t2) => {
          this.material.uniforms[t2].value = this.uniforms[t2].value;
        }), requestAnimationFrame(this.render.bind(this)), this.renderer.render({ scene: this.scene, camera: this.camera }));
      }
      destroy() {
        this.initialized = false, this.destroyed = true, this.gl && this.gl.canvas && this.container.removeChild(this.gl.canvas);
      }
    }
    return "undefined" != typeof window && window.SwiperElementRegisterParams && window.SwiperElementRegisterParams(["gl"]), function({ swiper: t2, on: e2, extendParams: i2 }) {
      t2.gl = null;
      let s2 = false;
      i2({ gl: { shader: "random", shaderPerSlide: false, displacementMap: void 0 } });
      const r2 = () => {
        t2.gl = new vt({ swiper: t2, shader: t2.params.gl.shader, shaderPerSlide: t2.params.gl.shaderPerSlide, displacementMap: t2.params.gl.displacementMap });
      };
      let n2, a2;
      e2("beforeInit", () => {
        if ("gl" !== t2.params.effect)
          return;
        if (!function() {
          try {
            const t3 = document.createElement("canvas");
            return !!window.WebGLRenderingContext && (t3.getContext("webgl") || t3.getContext("experimental-webgl"));
          } catch (t3) {
            return false;
          }
        }())
          return void (s2 = true);
        t2.classNames.push(`${t2.params.containerModifierClass}gl`);
        const e3 = { watchSlidesProgress: true };
        Object.assign(t2.params, e3), Object.assign(t2.originalParams, e3);
      }), e2("init", () => {
        "gl" !== t2.params.effect || s2 || t2.glDestroyed || t2.gl || r2();
      }), e2("resize", () => {
        "gl" !== t2.params.effect || s2 || t2.glDestroyed || t2.gl.resize();
      }), e2("setTranslate", () => {
        if ("gl" !== t2.params.effect || s2 || t2.glDestroyed)
          return;
        let e3, i3, o2;
        t2.gl || r2();
        let h2, l2 = false;
        if (t2.slides.forEach((s3, r3) => {
          const n3 = s3.progress;
          t2.params.cssMode && 0 === Math.round(100 * n3) && (l2 = true), (n3 > 0 && n3 < 1 || 0 === n3 && t2.progress < a2) && (e3 = r3, i3 = r3 + 1, o2 = n3, h2 = e3), (n3 < 0 && n3 > -1 || 0 === n3 && t2.progress > a2) && (e3 = r3 - 1, i3 = r3, o2 = 1 + n3, h2 = i3);
        }), a2 = t2.progress || 0, void 0 === e3 && void 0 === i3)
          return;
        l2 = l2 && Math.round(o2) === o2;
        const c2 = Math.min(h2, t2.activeIndex), u2 = Math.max(h2, t2.activeIndex);
        t2.params.loop || u2 === c2 || (e3 = c2, i3 = u2), t2.gl.setProgress(e3, i3, o2, n2, l2);
      }), e2("setTransition", (e3, i3) => {
        "gl" !== t2.params.effect || s2 || t2.glDestroyed || (n2 = i3 > 0 && !t2.params.cssMode);
      }), e2("slidesGridLengthChange", () => {
        "gl" !== t2.params.effect || s2 || !t2.initialized || t2.glDestroyed || t2.gl && t2.gl.loadTextures && t2.gl.loadTextures();
      }), e2("beforeDestroy", () => {
        "gl" !== t2.params.effect || s2 || t2.gl && (t2.glDestroyed = true, t2.gl.destroy(), t2.gl = null);
      });
    };
  });
})();
//# sourceMappingURL=swiper-gl.min.js.map
